/ *!
 * Thư viện JavaScript jQuery v3.5.0
 * https://jquery.com/
 *
 * Bao gồm Sizzle.js
 * https://sizzlejs.com/
 *
 * Tổ chức Copyright JS Foundation và các cộng tác viên khác
 * Được phát hành theo giấy phép MIT
 * https://jquery.org/license
 *
 * Ngày: 2020-04-10T15: 07Z
 * /
(chức năng (toàn cầu, nhà máy) {

	"Sử dụng nghiêm ngặt";

	if (typeof module === "object" && typeof module.exports === "object") {

		// Đối với môi trường giống CommonJS và CommonJS, nơi có `cửa sổ 'thích hợp
		// hiện diện, thực thi nhà máy và nhận jQuery.
		// Đối với môi trường không có `cửa sổ` với` tài liệu`
		// (chẳng hạn như Node.js), hiển thị một nhà máy dưới dạng module.exports.
		// Điều này làm nổi bật nhu cầu tạo một `cửa sổ` thực.
		// ví dụ: var jQuery = demand ("jquery") (window);
		// Xem vé số 14549 để biết thêm thông tin.
		module.exports = global.document?
			nhà máy (toàn cầu, đúng):
			hàm (w) {
				if (! w.document) {
					ném lỗi mới ("jQuery yêu cầu một cửa sổ có tài liệu");
				}
				trả lại nhà máy (w);
			};
	} khác {
		nhà máy (toàn cầu);
	}

// Chuyển cái này nếu cửa sổ chưa được xác định
}) (typeof window! == "undefined"? window: this, function (window, noGlobal) {

// Edge <= 12 - 13+, Firefox <= 18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// ném các ngoại lệ khi mã không nghiêm ngặt (ví dụ: ASP.NET 4.5) truy cập chế độ nghiêm ngặt
// đối số.callee.caller (trac-13335). Nhưng kể từ jQuery 3.0 (2016), chế độ nghiêm ngặt sẽ phổ biến
// đủ để tất cả các lần thử như vậy được bảo vệ trong một khối thử.
"Sử dụng nghiêm ngặt";

var arr = [];

var getProto = Object.getPrototypeOf;

var lát = arr.slice;

var flat = arr.flat? hàm (mảng) {
	trả về arr.flat.call (mảng);
}: function (array) {
	trả về arr.concat.apply ([], mảng);
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call (Đối tượng);

var support = {};

var isFunction = function isFunction (obj) {

      // Hỗ trợ: Chrome <= 57, Firefox <= 52
      // Trong một số trình duyệt, typeof trả về "hàm" cho các phần tử HTML <object>
      // (ví dụ: `typeof document.createElement (" object ") ===" function "`).
      // Chúng tôi không muốn phân loại * bất kỳ nút * DOM nào là một hàm.
      trả về typeof obj === "function" && typeof obj.nodeType! == "number";
  };


var isWindow = function isWindow (obj) {
		trả về obj! = null && obj === obj.window;
	};


var document = window.document;



	var secureScriptAttributes = {
		loại: true,
		src: true,
		nonce: đúng,
		noModule: true
	};

	function DOMEval (mã, nút, doc) {
		doc = doc || tài liệu;

		var i, val,
			script = doc.createElement ("script");

		script.text = mã;
		if (nút) {
			cho (tôi trong bảo tồnScriptAttributes) {

				// Hỗ trợ: Firefox 64+, Edge 18+
				// Một số trình duyệt không hỗ trợ thuộc tính "nonce" trên các tập lệnh.
				// Mặt khác, chỉ sử dụng `getAttribute` là không đủ vì
				// thuộc tính `nonce` được đặt lại thành một chuỗi trống bất cứ khi nào nó
				// trở nên duyệt-ngữ cảnh được kết nối.
				// Xem https://github.com/whatwg/html/issues/2369
				// Xem https://html.spec.whatwg.org/#nonce-attributes
				// Kiểm tra `node.getAttribute` đã được thêm vào vì lợi ích của
				// `jQuery.globalEval` để nó có thể giả mạo một nút chứa nonce
				// thông qua một đối tượng.
				val = nút [i] || node.getAttribute && node.getAttribute (i);
				if (val) {
					script.setAttribute (i, val);
				}
			}
		}
		doc.head.appendChild (script) .parentNode.removeChild (script);
	}


function toType (obj) {
	if (obj == null) {
		return obj + "";
	}

	// Hỗ trợ: chỉ dành cho Android <= 2.3 (chức năng RegExp)
	trả về typeof obj === "object" || typeof obj === "chức năng"?
		class2type [toString.call (obj)] || "vật" :
		loại đối tượng;
}
/ * Biểu tượng toàn cầu * /
// Định nghĩa toàn cục này trong .eslintrc.json sẽ tạo ra nguy cơ sử dụng toàn cục
// không được bảo vệ ở một nơi khác, có vẻ như an toàn hơn khi chỉ định nghĩa toàn cục cho mô-đun này



var
	phiên bản = "3.5.0",

	// Xác định bản sao cục bộ của jQuery
	jQuery = function (selector, context) {

		// Đối tượng jQuery thực chất chỉ là hàm tạo init 'nâng cao'
		// Cần init nếu jQuery được gọi (chỉ cho phép ném lỗi nếu không có)
		trả về jQuery.fn.init mới (bộ chọn, ngữ cảnh);
	};

jQuery.fn = jQuery.prototype = {

	// Phiên bản hiện tại của jQuery đang được sử dụng
	jquery: phiên bản,

	hàm tạo: jQuery,

	// Độ dài mặc định của một đối tượng jQuery là 0
	chiều dài: 0,

	toArray: function () {
		trả về Slice.call (this);
	},

	// Lấy phần tử thứ N trong tập phần tử đã so khớp HOẶC
	// Lấy toàn bộ tập hợp phần tử đã so khớp dưới dạng một mảng sạch
	get: function (num) {

		// Trả về tất cả các phần tử trong một mảng sạch
		if (num == null) {
			trả về Slice.call (this);
		}

		// Chỉ trả về một phần tử từ tập hợp
		trả về num <0? this [num + this.length]: this [num];
	},

	// Lấy một mảng các phần tử và đẩy nó vào ngăn xếp
	// (trả về tập hợp phần tử phù hợp mới)
	pushStack: function (elems) {

		// Xây dựng một tập hợp phần tử phù hợp jQuery mới
		var ret = jQuery.merge (this.constructor (), elems);

		// Thêm đối tượng cũ vào ngăn xếp (làm tham chiếu)
		ret.prevObject = this;

		// Trả về tập hợp phần tử mới tạo
		trả lại ret;
	},

	// Thực thi một lệnh gọi lại cho mọi phần tử trong tập hợp đã so khớp.
	each: function (callback) {
		return jQuery.each (this, callback);
	},

	map: function (callback) {
		return this.pushStack (jQuery.map (this, function (elem, i) {
			trả về callback.call (elem, i, elem);
		}));
	},

	Slice: function () {
		return this.pushStack (slice.apply (this, các đối số));
	},

	đầu tiên: function () {
		return this.eq (0);
	},

	last: function () {
		return this.eq (-1);
	},

	hàm chẵn() {
		return this.pushStack (jQuery.grep (this, function (_elem, i) {
			trả về (i + 1)% 2;
		}));
	},

	lẻ: function () {
		return this.pushStack (jQuery.grep (this, function (_elem, i) {
			trả lại i% 2;
		}));
	},

	eq: function (i) {
		var len = this.length,
			j = + i + (i <0? len: 0);
		return this.pushStack (j> = 0 && j <len? [this [j]]: []);
	},

	end: function () {
		trả về this.prevObject || this.constructor ();
	},

	// Chỉ sử dụng nội bộ.
	// Hoạt động giống như một phương thức của Array, không giống như một phương thức jQuery.
	đẩy đẩy,
	sắp xếp: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function () {
	tùy chọn var, tên, src, sao chép, copyIsArray, bản sao,
		target = đối số [0] || {},
		i = 1,
		chiều dài = đối số.length,
		sâu = giả dối;

	// Xử lý tình huống sao chép sâu
	if (typeof target === "boolean") {
		sâu = tiêu;

		// Bỏ qua boolean và target
		target = đối số [i] || {};
		i ++;
	}

	// Xử lý trường hợp khi đích là một chuỗi hoặc một cái gì đó (có thể trong bản sao sâu)
	if (typeof target! == "object" &&! isFunction (target)) {
		target = {};
	}

	// Tự mở rộng jQuery nếu chỉ một đối số được truyền
	if (i === length) {
		target = cái này;
		tôi--;
	}

	for (; i <length; i ++) {

		// Chỉ xử lý các giá trị không phải null / không xác định
		if ((tùy chọn = đối số [i])! = null) {

			// Mở rộng đối tượng cơ sở
			cho (tên trong tùy chọn) {
				copy = options [tên];

				// Ngăn chặn ô nhiễm Object.prototype
				// Ngăn chặn vòng lặp không bao giờ kết thúc
				if (name === "__proto__" || target === copy) {
					tiếp tục;
				}

				// Đệ quy nếu chúng ta đang hợp nhất các đối tượng hoặc mảng thuần túy
				if (deep && copy && (jQuery.isPlainObject (copy) ||
					(copyIsArray = Array.isArray (copy)))) {
					src = target [tên];

					// Đảm bảo loại phù hợp cho giá trị nguồn
					if (copyIsArray &&! Array.isArray (src)) {
						phân thân = [];
					} else if (! copyIsArray &&! jQuery.isPlainObject (src)) {
						nhân bản = {};
					} khác {
						nhân bản = src;
					}
					copyIsArray = false;

					// Không bao giờ di chuyển các đối tượng gốc, sao chép chúng
					target [name] = jQuery.extend (deep, clone, copy);

				// Không mang lại các giá trị không xác định
				} else if (copy! == undefined) {
					target [name] = copy;
				}
			}
		}
	}

	// Trả về đối tượng đã sửa đổi
	mục tiêu trở lại;
};

jQuery.extend ({

	// Duy nhất cho mỗi bản sao của jQuery trên trang
	expando: "jQuery" + (version + Math.random ()) .replace (/ \ D / g, ""),

	// Giả sử jQuery đã sẵn sàng mà không có mô-đun sẵn sàng
	isReady: đúng,

	error: function (msg) {
		ném lỗi mới (msg);
	},

	noop: function () {},

	isPlainObject: function (obj) {
		var proto, Ctor;

		// Phát hiện các phủ định rõ ràng
		// Sử dụng toString thay vì jQuery.type để bắt các đối tượng máy chủ
		if (! obj || toString.call (obj)! == "[object Object]") {
			trả về sai;
		}

		proto = getProto (obj);

		// Các đối tượng không có nguyên mẫu (ví dụ: `Object.create (null)`) là đơn giản
		if (! proto) {
			trả về true;
		}

		// Các đối tượng có nguyên mẫu là đơn giản, chúng được tạo bởi một hàm Đối tượng toàn cục
		Ctor = hasOwn.call (proto, "constructor") && proto.constructor;
		return typeof Ctor === "function" && fnToString.call (Ctor) === ObjectFunctionString;
	},

	isEmptyObject: function (obj) {
		tên var;

		cho (tên trong obj) {
			trả về sai;
		}
		trả về true;
	},

	// Đánh giá một tập lệnh trong ngữ cảnh được cung cấp; rơi trở lại toàn cầu
	// nếu không được chỉ định.
	globalEval: function (code, options, doc) {
		DOMEval (mã, {nonce: options && options.nonce}, doc);
	},

	each: function (obj, callback) {
		var chiều dài, i = 0;

		if (isArrayLike (obj)) {
			chiều dài = obj.length;
			for (; i <length; i ++) {
				if (callback.call (obj [i], i, obj [i]) === false) {
					phá vỡ;
				}
			}
		} khác {
			cho (tôi trong obj) {
				if (callback.call (obj [i], i, obj [i]) === false) {
					phá vỡ;
				}
			}
		}

		trả lại obj;
	},

	// kết quả chỉ dành cho việc sử dụng nội bộ
	makeArray: function (arr, results) {
		var ret = kết quả || [];

		if (arr! = null) {
			if (isArrayLike (Object (arr))) {
				jQuery.merge (ret,
					typeof arr === "chuỗi"?
					[arr]: arr
				);
			} khác {
				push.call (ret, arr);
			}
		}

		trả lại ret;
	},

	inArray: function (elem, arr, i) {
		trả về arr == null? -1: indexOf.call (arr, elem, i);
	},

	// Hỗ trợ: chỉ Android <= 4.0, chỉ PhantomJS 1
	// push.apply (_, arraylike) ném trên WebKit cổ
	merge: function (thứ nhất, thứ hai) {
		var len = + second.length,
			j = 0,
			i = first.length;

		for (; j <len; j ++) {
			đầu tiên [i ++] = thứ hai [j];
		}

		first.length = i;

		trở về trước;
	},

	grep: function (elems, callback, invert) {
		var callbackInverse,
			phù hợp với = [],
			i = 0,
			length = elems.length,
			callbackExpect =! invert;

		// Đi qua mảng, chỉ lưu các mục
		// vượt qua hàm xác nhận
		for (; i <length; i ++) {
			callbackInverse =! callback (elems [i], i);
			if (callbackInverse! == callbackExpect) {
				trận đấu.push (elems [i]);
			}
		}

		các trận đấu trở lại;
	},

	// arg chỉ dành cho việc sử dụng nội bộ
	map: function (elems, callback, arg) {
		var chiều dài, giá trị,
			i = 0,
			ret = [];

		// Đi qua mảng, dịch từng mục sang giá trị mới của chúng
		if (isArrayLike (elems)) {
			chiều dài = elems.length;
			for (; i <length; i ++) {
				value = callback (elems [i], i, arg);

				if (value! = null) {
					ret.push (giá trị);
				}
			}

		// Đi qua mọi phím trên đối tượng,
		} khác {
			cho (tôi tính bằng elems) {
				value = callback (elems [i], i, arg);

				if (value! = null) {
					ret.push (giá trị);
				}
			}
		}

		// Làm phẳng mọi mảng lồng nhau
		trả lại bằng phẳng (ret);
	},

	// Một bộ đếm GUID toàn cục cho các đối tượng
	hướng dẫn: 1,

	// jQuery.support không được sử dụng trong Core nhưng các dự án khác đính kèm
	// thuộc tính của nó để nó cần tồn tại.
	support: hỗ trợ
});

if (typeof Symbol === "function") {
	jQuery.fn [Symbol.iterator] = arr [Symbol.iterator];
}

// Điền vào bản đồ class2type
jQuery.each ("Chuỗi Hàm Số Boolean Mảng Ngày Ký hiệu Lỗi Đối tượng RegExp" .split (""),
function (_i, name) {
	class2type ["[object" + name + "]"] = name.toLowerCase ();
});

function isArrayLike (obj) {

	// Hỗ trợ: chỉ iOS 8.2 thực (không thể tái tạo trong trình mô phỏng)
	// Kiểm tra `in` được sử dụng để ngăn lỗi JIT (gh-2145)
	// hasOwn không được sử dụng ở đây do phủ định sai
	// liên quan đến độ dài Nodelist trong IE
	var length = !! obj && "length" trong obj && obj.length,
		type = toType (obj);

	if (isFunction (obj) || isWindow (obj)) {
		trả về sai;
	}

	kiểu trả về === "mảng" || chiều dài === 0 ||
		typeof length === "number" && length> 0 && (length - 1) trong obj;
}
var Sizzle =
/ *!
 * Sizzle CSS Selector Engine v2.3.5
 * https://sizzlejs.com/
 *
 * Tổ chức Copyright JS Foundation và các cộng tác viên khác
 * Được phát hành theo giấy phép MIT
 * https://js.foundation/
 *
 * Ngày: 2020-03-14
 * /
(hàm (cửa sổ) {
var i,
	ủng hộ,
	Expr,
	getText,
	isXML,
	mã hóa,
	biên dịch,
	lựa chọn,
	ngoài cùngContext,
	sortInput,
	hasDuplicate,

	// Kho tài liệu cục bộ
	setDocument,
	tài liệu,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	diêm,
	chứa,

	// Dữ liệu dành riêng cho phiên bản cụ thể
	expando = "sizzle" + 1 * mới Ngày (),
	Doc = window.document,
	dirruns = 0,
	xong = 0,
	classCache = createCache (),
	tokenCache = createCache (),
	compilerCache = createCache (),
	nonnativeSelectorCache = createCache (),
	sortOrder = function (a, b) {
		nếu (a === b) {
			hasDuplicate = true;
		}
		trả về 0;
	},

	// Phương thức phiên bản
	hasOwn = ({}) .hasOwnProperty,
	arr = [],
	pop = arr.pop,
	pushNative = arr.push,
	push = arr.push,
	Slice = arr.slice,

	// Sử dụng indexOf rút gọn vì nó nhanh hơn bản gốc
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function (list, elem) {
		var i = 0,
			len = list.length;
		for (; i <len; i ++) {
			if (list [i] === elem) {
				trả lại tôi;
			}
		}
		trả về -1;
	},

	booleans = "đã kiểm tra | đã chọn | không đồng bộ | tự động lấy nét | tự động phát | điều khiển | trì hoãn | vô hiệu hóa | ẩn |" +
		"ismap | loop | nhiều | mở | chỉ đọc | bắt buộc | phạm vi",

	// Biểu thức chính quy

	// http://www.w3.org/TR/css3-selectors/#whitespace
	khoảng trắng = "[\\ x20 \\ t \\ r \\ n \\ f]",

	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	định danh = "(?: \\\\ [\\ da-fA-F] {1,6}" + khoảng trắng +
		"? | \\\\ [^ \\ r \\ n \\ f] | [\\ w-] | [^ \ 0 - \\ x7f]) +",

	// Bộ chọn thuộc tính: http://www.w3.org/TR/selectors/#attribute-selectors
	thuộc tính = "\\ [" + khoảng trắng + "* (" + số nhận dạng + ") (?:" + khoảng trắng +

		// Toán tử (bắt 2)
		"* ([* ^ $ |! ~]? =)" + khoảng trắng +

		// "Giá trị thuộc tính phải là số nhận dạng CSS [capture 5]
		// hoặc chuỗi [chụp 3 hoặc chụp 4] "
		"* (?: '((?: \\\\\. | [^ \\\\\']) *) '| \" ((?: \\\\. | [^ \\\\\ "] ) *) \ "| (" + số nhận dạng + ")) |)" +
		khoảng trắng + "* \\]",

	pseudos = ":(" + số nhận dạng + ") (?: \\ ((" +

		// Để giảm số lượng bộ chọn cần mã hóa trong PreFilter, ưu tiên các đối số:
		// 1. trích dẫn (chụp 3; chụp 4 hoặc chụp 5)
		"('((?: \\\\. | [^ \\\\']) *) '| \" ((?: \\\\. | [^ \\\\\ "]) *) \ ") |" +

		// 2. đơn giản (chụp 6)
		"((?: \\\\. | [^ \\\\ () [\\]] |" + thuộc tính + ") *) |" +

		// 3. bất kỳ thứ gì khác (chụp 2)
		". *" +
		") \\) |)",

	// Khoảng trắng ở cuối hàng đầu và không thoát, ghi lại một số ký tự không có khoảng trắng đứng trước ký tự sau
	rwhitespace = new RegExp (khoảng trắng + "+", "g"),
	rtrim = new RegExp ("^" + khoảng trắng + "+ | ((?: ^ | [^ \\\\]) (?: \\\\.) *)" +
		khoảng trắng + "+ $", "g"),

	rcomma = new RegExp ("^" + khoảng trắng + "*," + khoảng trắng + "*"),
	rcombinators = new RegExp ("^" + khoảng trắng + "* ([> + ~] |" + khoảng trắng + ")" + khoảng trắng +
		"*"),
	rdescend = new RegExp (khoảng trắng + "|>"),

	rpseudo = new RegExp (giả),
	ridentifier = new RegExp ("^" + mã định danh + "$"),

	matchExpr = {
		"ID": new RegExp ("^ # (" + số nhận dạng + ")"),
		"CLASS": new RegExp ("^ \\. (" + Số nhận dạng + ")"),
		"TAG": mới RegExp ("^ (" + mã định danh + "| [*])"),
		"ATTR": RegExp mới ("^" + thuộc tính),
		"PSEUDO": RegExp mới ("^" + bút danh),
		"CHILD": new RegExp ("^ :( only | first | last | nth | nth-last) - (con | of-type) (?: \\ (" +
			khoảng trắng + "* (chẵn | lẻ | (([+ -] |) (\\ d *) n |)" + khoảng trắng + "* (?: ([+ -] |)" +
			khoảng trắng + "* (\\ d +) |))" + khoảng trắng + "* \\) |)", "i"),
		"bool": new RegExp ("^ (?:" + booleans + ") $", "i"),

		// Để sử dụng trong các thư viện triển khai .is ()
		// Chúng tôi sử dụng điều này để đối sánh POS trong `select`
		"needContext": new RegExp ("^" + khoảng trắng +
			"* [> + ~] |: (chẵn | lẻ | eq | gt | lt | nth | first | last) (?: \\ (" + khoảng trắng +
			"* ((?: - \\ d)? \\ d *)" + khoảng trắng + "* \\) |) (? = [^ -] | $)", "i")
	},

	rhtml = / HTML $ / i,
	rinputs = / ^ (?: input | select | textarea | button) $ / i,
	rheader = / ^ h \ d $ / i,

	rnative = / ^ [^ {] + \ {\ s * \ [bản địa \ w /,

	// Các bộ chọn ID hoặc TAG hoặc CLASS có thể phân tích cú pháp / có thể truy xuất dễ dàng
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = / [+ ~] /,

	// CSS thoát
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp ("\\\\ [\\ da-fA-F] {1,6}" + khoảng trắng + "? | \\\\ ([^ \\ r \\ n \\ f])" , "g"),
	funescape = function (Escape, nonHex) {
		var high = "0x" + Escape.slice (1) - 0x10000;

		trả về nonHex?

			// Loại bỏ tiền tố dấu gạch chéo ngược khỏi chuỗi thoát không phải hex
			nonHex:

			// Thay thế chuỗi thoát thập lục phân bằng điểm mã Unicode được mã hóa
			// Hỗ trợ: IE <= 11 +
			// Đối với các giá trị bên ngoài Mặt phẳng Đa ngôn ngữ Cơ bản (BMP), hãy xây dựng một
			// cặp thay thế
			cao <0?
				String.fromCharCode (cao + 0x10000):
				String.fromCharCode (cao >> 10 | 0xD800, cao & 0x3FF | 0xDC00);
	},

	// Tuần tự hóa chuỗi / mã nhận dạng CSS
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = / ([\ 0- \ x1f \ x7f] | ^ -? \ d) | ^ - $ | [^ \ 0- \ x1f \ x7f- \ uFFFF \ w -] / g,
	fcssescape = function (ch, asCodePoint) {
		if (asCodePoint) {

			// U + 0000 NULL trở thành KÝ TỰ THAY THẾ U + FFFD
			if (ch === "\ 0") {
				trả về "\ uFFFD";
			}

			// Các ký tự điều khiển và số (phụ thuộc vào vị trí) được thoát ra dưới dạng điểm mã
			trả về ch.slice (0, -1) + "\\" +
				ch.charCodeAt (ch.length - 1) .toString (16) + "";
		}

		// Các ký tự ASCII có khả năng đặc biệt khác được thoát khỏi dấu gạch chéo ngược
		return "\\" + ch;
	},

	// Được sử dụng cho iframe
	// Xem setDocument ()
	// Loại bỏ trình bao bọc chức năng gây ra "Quyền bị từ chối"
	// lỗi trong IE
	unloadHandler = function () {
		setDocument ();
	},

	inDisabledFieldset = addCombinator (
		hàm (elem) {
			trả về elem.disabled === true && elem.nodeName.toLowerCase () === "tập trường";
		},
		{dir: "parentNode", tiếp theo: "legend"}
	);

// Tối ưu hóa cho push.apply (_, NodeList)
thử {
	push.apply (
		(arr = slice.call (Doc.childNodes) được ưa thích),
		ưa thíchDoc.childNodes
	);

	// Hỗ trợ: Android <4.0
	// Phát hiện âm thầm không thành công push.apply
	// eslint-disable-next-line no-used-expression
	arr [favouriteDoc.childNodes.length] .nodeType;
} bắt (e) {
	push = {apply: arr.length?

		// Đòn bẩy nếu có thể
		function (target, els) {
			pushNative.apply (target, slice.call (els));
		}:

		// Hỗ trợ: IE <9
		// Nếu không thì nối trực tiếp
		function (target, els) {
			var j = target.length,
				i = 0;

			// Không thể tin tưởng NodeList.length
			while ((target [j ++] = els [i ++])) {}
			target.length = j - 1;
		}
	};
}

function Sizzle (bộ chọn, ngữ cảnh, kết quả, hạt giống) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType mặc định là 9, vì ngữ cảnh mặc định là document
		nodeType = ngữ cảnh? context.nodeType: 9;

	results = kết quả || [];

	// Trở về sớm từ các cuộc gọi có bộ chọn hoặc ngữ cảnh không hợp lệ
	if (typeof selector! == "string" ||! selector ||
		nodeType! == 1 && nodeType! == 9 && nodeType! == 11) {

		trả kết quả;
	}

	// Cố gắng thực hiện các thao tác tìm phím tắt (trái ngược với bộ lọc) trong tài liệu HTML
	if (! seed) {
		setDocument (ngữ cảnh);
		context = bối cảnh || tài liệu;

		if (documentIsHTML) {

			// Nếu bộ chọn đủ đơn giản, hãy thử sử dụng phương thức DOM "get * By *"
			// (ngoại trừ ngữ cảnh DocumentFragment, nơi các phương thức không tồn tại)
			if (nodeType! == 11 && (match = rquickExpr.exec (selector))) {

				// Bộ chọn ID
				if ((m = match [1])) {

					// Ngữ cảnh tài liệu
					if (nodeType === 9) {
						if ((elem = context.getElementById (m))) {

							// Hỗ trợ: IE, Opera, Webkit
							// VIỆC CẦN LÀM: xác định phiên bản
							// getElementById có thể so khớp các phần tử theo tên thay vì ID
							nếu (elem.id === m) {
								results.push (elem);
								trả kết quả;
							}
						} khác {
							trả kết quả;
						}

					// Ngữ cảnh phần tử
					} khác {

						// Hỗ trợ: IE, Opera, Webkit
						// VIỆC CẦN LÀM: xác định phiên bản
						// getElementById có thể so khớp các phần tử theo tên thay vì ID
						if (newContext && (elem = newContext.getElementById (m)) &&
							chứa (ngữ cảnh, elem) &&
							elem.id === m) {

							results.push (elem);
							trả kết quả;
						}
					}

				// Gõ bộ chọn
				} else if (khớp với [2]) {
					push.apply (kết quả, context.getElementsByTagName (bộ chọn));
					trả kết quả;

				// Bộ chọn lớp
				} else if ((m = match [3]) && support.getElementsByClassName &&
					context.getElementsByClassName) {

					push.apply (kết quả, context.getElementsByClassName (m));
					trả kết quả;
				}
			}

			// Tận dụng querySelectorAll
			nếu (support.qsa &&
				! nonnativeSelectorCache [selector + ""] &&
				(! rbuggyQSA ||! rbuggyQSA.test (bộ chọn)) &&

				// Hỗ trợ: chỉ IE 8
				// Loại trừ các phần tử đối tượng
				(nodeType! == 1 || context.nodeName.toLowerCase ()! == "object")) {

				newSelector = bộ chọn;
				newContext = ngữ cảnh;

				// qSA xem xét các phần tử bên ngoài gốc phạm vi khi đánh giá con hoặc
				// các tổ hợp con cháu, không phải là những gì chúng ta muốn.
				// Trong những trường hợp như vậy, chúng tôi giải quyết hành vi bằng cách thêm tiền tố vào mọi bộ chọn trong
				// danh sách có bộ chọn ID tham chiếu đến ngữ cảnh phạm vi.
				// Kỹ thuật này cũng phải được sử dụng khi sử dụng bộ tổ hợp đứng đầu
				// vì các bộ chọn như vậy không được querySelectorAll nhận dạng.
				// Cảm ơn Andrew Dupont về kỹ thuật này.
				if (nodeType === 1 &&
					(rdescend.test (bộ chọn) || rcombinators.test (bộ chọn))) {

					// Mở rộng ngữ cảnh cho các bộ chọn anh chị em
					newContext = rsibling.test (bộ chọn) && testContext (context.parentNode) ||
						bối cảnh;

					// Chúng ta có thể sử dụng: scope thay vì ID hack nếu trình duyệt
					// hỗ trợ nó & nếu chúng ta không thay đổi ngữ cảnh.
					if (newContext! == context ||! support.scope) {

						// Chụp ID ngữ cảnh, đặt nó trước nếu cần
						if ((nid = context.getAttribute ("id"))) {
							nid = nid.replace (rcssescape, fcssescape);
						} khác {
							context.setAttribute ("id", (nid = expando));
						}
					}

					// Đặt tiền tố cho mọi bộ chọn trong danh sách
					nhóm = mã hóa (bộ chọn);
					i = groups.length;
					trong khi tôi-- ) {
						nhóm [i] = (nid? "#" + nid: ": scope") + "" +
							toSelector (nhóm [i]);
					}
					newSelector = groups.join (",");
				}

				thử {
					push.apply (kết quả,
						newContext.querySelectorAll (newSelector)
					);
					trả kết quả;
				} bắt (qsaError) {
					nonnativeSelectorCache (bộ chọn, đúng);
				} cuối cùng {
					if (nid === expando) {
						context.removeAttribute ("id");
					}
				}
			}
		}
	}

	// Tất cả những người khác
	trả về lựa chọn (selector.replace (rtrim, "$ 1"), ngữ cảnh, kết quả, hạt giống);
}

/ **
 * Tạo bộ nhớ đệm khóa-giá trị có kích thước giới hạn
 * @returns {function (string, object)} Trả về dữ liệu Đối tượng sau khi lưu trữ trên chính nó với
 * tên thuộc tính là chuỗi (hậu tố khoảng trắng) và (nếu bộ nhớ đệm lớn hơn Expr.cacheLength)
 * xóa mục nhập cũ nhất
 * /
function createCache () {
	các phím var = [];

	bộ đệm hàm (khóa, giá trị) {

		// Sử dụng (key + "") để tránh va chạm với các thuộc tính nguyên mẫu (xem Sự cố # 157)
		if (key.push (key + "")> Expr.cacheLength) {

			// Chỉ giữ lại các mục nhập gần đây nhất
			xóa bộ nhớ cache [key.shift ()];
		}
		return (cache [key + ""] = value);
	}
	trả lại bộ nhớ cache;
}

/ **
 * Đánh dấu một chức năng để sử dụng đặc biệt bởi Sizzle
 * @param {Function} fn Hàm để đánh dấu
 * /
function markFunction (fn) {
	fn [expando] = true;
	trả về fn;
}

/ **
 * Hỗ trợ kiểm tra bằng cách sử dụng một phần tử
 * @param {Function} fn Truyền phần tử đã tạo và trả về kết quả boolean
 * /
function khẳng định (fn) {
	var el = document.createElement ("tập trường");

	thử {
		quay lại !! fn (el);
	} bắt (e) {
		trả về sai;
	} cuối cùng {

		// Xóa khỏi trang gốc của nó theo mặc định
		if (el.parentNode) {
			el.parentNode.removeChild (el);
		}

		// giải phóng bộ nhớ trong IE
		el = null;
	}
}

/ **
 * Thêm cùng một trình xử lý cho tất cả các phần đính kèm được chỉ định
 * @param {String} attrs Danh sách các thuộc tính được phân tách bằng đường ống
 Trình xử lý * @param {Function} Phương thức sẽ được áp dụng
 * /
function addHandle (attrs, handler) {
	var arr = attrs.split ("|"),
		i = arr.length;

	trong khi tôi-- ) {
		Expr.attrHandle [arr [i]] = trình xử lý;
	}
}

/ **
 * Kiểm tra thứ tự tài liệu của hai anh em ruột
 * @param {Element} a
 * @param {Phần tử} b
 * @returns {Number} Trả về nhỏ hơn 0 nếu a đứng trước b, lớn hơn 0 nếu a đứng sau b
 * /
chức năng anh chị emCheck (a, b) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Sử dụng IE sourceIndex nếu có trên cả hai nút
	nếu (khác) {
		trả về khác biệt;
	}

	// Kiểm tra xem b có theo sau a không
	if (cur) {
		while ((cur = cur.nextSibling)) {
			if (cur === b) {
				trả về -1;
			}
		}
	}

	trả lại a? 1: -1;
}

/ **
 * Trả về một hàm để sử dụng trong giả cho các loại đầu vào
 * @param {String} loại
 * /
function createInputPseudo (type) {
	hàm trả về (elem) {
		var name = elem.nodeName.toLowerCase ();
		trả về tên === "đầu vào" && elem.type === loại;
	};
}

/ **
 * Trả về một hàm để sử dụng trong giả cho các nút
 * @param {String} loại
 * /
function createButtonPseudo (type) {
	hàm trả về (elem) {
		var name = elem.nodeName.toLowerCase ();
		return (tên === "đầu vào" || tên === "nút") && elem.type === loại;
	};
}

/ **
 * Trả về một hàm để sử dụng trong giả cho: đã bật /: đã vô hiệu hóa
 * @param {Boolean} bị vô hiệu hóa true đối với: bị vô hiệu hóa; false cho: đã bật
 * /
function createDisabledPseudo (bị vô hiệu hóa) {

	// Đã biết: đã vô hiệu hóa sai xác thực: fieldset [vô hiệu]> chú giải: nth-of-type (n + 2): can-vô hiệu hóa
	hàm trả về (elem) {

		// Chỉ một số phần tử nhất định có thể khớp: đã bật hoặc: đã vô hiệu hóa
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ("form" trong elem) {

			// Kiểm tra tình trạng khuyết tật kế thừa trên các phần tử không bị khuyết tật có liên quan:
			// * các phần tử liên kết với biểu mẫu được liệt kê trong một tập trường bị vô hiệu hóa
			// https://html.spec.whatwg.org/multipage/forms.html#category-listed
			// https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * các phần tử tùy chọn trong nhóm chọn bị vô hiệu hóa
			// https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// Tất cả các phần tử như vậy đều có thuộc tính "form".
			if (elem.parentNode && elem.disabled === false) {

				// Các phần tử tùy chọn chuyển sang nhóm chọn chính nếu có
				if ("nhãn" tính bằng elem) {
					if ("nhãn" trong elem.parentNode) {
						trả về elem.parentNode.disabled === tắt;
					} khác {
						return elem.disabled === bị vô hiệu hóa;
					}
				}

				// Hỗ trợ: IE 6 - 11
				// Sử dụng thuộc tính phím tắt isDisabled để kiểm tra tổ tiên bộ trường bị vô hiệu hóa
				trả về elem.isDisabled === tắt ||

					// Trường hợp không có isDisabled, hãy kiểm tra theo cách thủ công
					/ * jshint -W018 * /
					elem.isDisabled! ==! đã tắt &&
					inDisabledFieldset (elem) === bị vô hiệu hóa;
			}

			return elem.disabled === bị vô hiệu hóa;

		// Cố gắng tìm ra các phần tử không thể bị vô hiệu hóa trước khi tin tưởng vào thuộc tính bị vô hiệu hóa.
		// Một số nạn nhân bị mắc vào lưới của chúng tôi (nhãn, chú giải, menu, bản nhạc), nhưng không nên
		// thậm chí tồn tại trên chúng, hãy để một mình có giá trị boolean.
		} else if ("nhãn" tính bằng elem) {
			return elem.disabled === bị vô hiệu hóa;
		}

		// Các phần tử còn lại đều không: được bật cũng như: bị vô hiệu hóa
		trả về sai;
	};
}

/ **
 * Trả về một hàm để sử dụng trong giả cho các vị trí
 * @param {Function} fn
 * /
function createPositionalPseudo (fn) {
	trả về markFunction (hàm (đối số) {
		đối số = + đối số;
		trả về markFunction (chức năng (hạt giống, kết quả phù hợp) {
			var j,
				matchIndexes = fn ([], seed.length, đối số),
				i = matchIndexes.length;

			// Khớp các phần tử được tìm thấy tại các chỉ mục được chỉ định
			trong khi tôi-- ) {
				if (seed [(j = matchIndexes [i])]) {
					seed [j] =! (so khớp [j] = seed [j]);
				}
			}
		});
	});
}

/ **
 * Kiểm tra tính hợp lệ của một nút dưới dạng ngữ cảnh Sizzle
 * @param {Element | Object =} ngữ cảnh
 * @returns {Element | Object | Boolean} Nút đầu vào nếu có thể chấp nhận được, nếu không sẽ là một giá trị sai
 * /
function testContext (context) {
	trả về ngữ cảnh && typeof context.getElementsByTagName! == "undefined" && context;
}

// Hiển thị các vars hỗ trợ để thuận tiện
hỗ trợ = Sizzle.support = {};

/ **
 * Phát hiện các nút XML
 * @param {Element | Object} elem Một phần tử hoặc một tài liệu
 * @returns {Boolean} True iff elem là một nút XML không phải HTML
 * /
isXML = Sizzle.isXML = function (elem) {
	var namespace = elem.namespaceURI,
		docElem = (elem.ownerDocument || elem) .documentElement;

	// Hỗ trợ: IE <= 8
	// Giả sử HTML khi documentElement chưa tồn tại, chẳng hạn như bên trong tải iframe
	// https://bugs.jquery.com/ticket/4833
	return! rhtml.test (không gian tên || docElem && docElem.nodeName || "HTML");
};

/ **
 * Đặt các biến liên quan đến tài liệu một lần dựa trên tài liệu hiện tại
 * @param {Element | Object} [doc] Một phần tử hoặc đối tượng tài liệu để sử dụng để thiết lập tài liệu
 * @returns {Object} Trả về tài liệu hiện tại
 * /
setDocument = Sizzle.setDocument = function (nút) {
	var hasCompare, subWindow,
		doc = nút? node.ownerDocument || nút: ưa thíchDoc;

	// Trả lại sớm nếu tài liệu không hợp lệ hoặc đã được chọn
	// Hỗ trợ: IE 11+, Edge 17 - 18+
	// IE / Edge đôi khi gặp lỗi "Quyền bị từ chối" khi so sánh chặt chẽ
	// hai tài liệu; so sánh nông cạn có tác dụng.
	// eslint-disable-next-line eqeqeq
	if (doc == document || doc.nodeType! == 9 ||! doc.documentElement) {
		trả lại tài liệu;
	}

	// Cập nhật các biến toàn cục
	document = doc;
	docElem = document.documentElement;
	documentIsHTML =! isXML (tài liệu);

	// Hỗ trợ: IE 9 - 11+, Edge 12 - 18+
	// Việc truy cập tài liệu iframe sau khi dỡ bỏ sẽ phát sinh lỗi "quyền bị từ chối" (jQuery # 13936)
	// Hỗ trợ: IE 11+, Edge 17 - 18+
	// IE / Edge đôi khi gặp lỗi "Quyền bị từ chối" khi so sánh chặt chẽ
	// hai tài liệu; so sánh nông cạn có tác dụng.
	// eslint-disable-next-line eqeqeq
	if (favouriteDoc! = document &&
		(subWindow = document.defaultView) && subWindow.top! == subWindow) {

		// Hỗ trợ: IE 11, Edge
		if (subWindow.addEventListener) {
			subWindow.addEventListener ("dỡ bỏ", dỡ bỏHandler, false);

		// Hỗ trợ: chỉ IE 9 - 10
		} else if (subWindow.attachEvent) {
			subWindow.attachEvent ("onunload", loadingHandler);
		}
	}

	// Hỗ trợ: IE 8 - 11+, Edge 12 - 18+, Chrome <= 16 - 25 only, Firefox <= 3.6 - 31 only,
	// Chỉ Safari 4 - 5, chỉ Opera <= 11.6 - 12.x
	// IE / Edge và các trình duyệt cũ hơn không hỗ trợ lớp giả: scope.
	// Hỗ trợ: chỉ Safari 6.0
	// Safari 6.0 hỗ trợ: scope nhưng nó là bí danh của: root ở đó.
	support.scope = khẳng định (function (el) {
		docElem.appendChild (el) .appendChild (document.createElement ("div"));
		return typeof el.querySelectorAll! == "undefined" &&
			! el.querySelectorAll (": scope fieldset div") .length;
	});

	/* Thuộc tính
	-------------------------------------------------- -------------------- * /

	// Hỗ trợ: IE <8
	// Xác minh rằng getAttribute thực sự trả về thuộc tính chứ không phải thuộc tính
	// (ngoại trừ boolean IE8)
	support.attributes = khẳng định (function (el) {
		el.className = "i";
		return! el.getAttribute ("className");
	});

	/ * getElement (s) Bởi *
	-------------------------------------------------- -------------------- * /

	// Kiểm tra xem getElementsByTagName ("*") chỉ trả về các phần tử hay không
	support.getElementsByTagName = khẳng định (function (el) {
		el.appendChild (document.createComment (""));
		return! el.getElementsByTagName ("*") .length;
	});

	// Hỗ trợ: IE <9
	support.getElementsByClassName = rnative.test (document.getElementsByClassName);

	// Hỗ trợ: IE <10
	// Kiểm tra xem getElementById có trả về các phần tử theo tên không
	// Các phương thức getElementById bị hỏng không chọn tên được đặt theo chương trình,
	// vì vậy hãy sử dụng kiểm tra getElementsByName vòng vo
	support.getById = khẳng định (function (el) {
		docElem.appendChild (el) .id = expando;
		return! document.getElementsByName || ! document.getElementsByName (expando) .length;
	});

	// Bộ lọc ID và tìm
	nếu (support.getById) {
		Expr.filter ["ID"] = function (id) {
			var attrId = id.replace (runescape, funescape);
			hàm trả về (elem) {
				trả về elem.getAttribute ("id") === attrId;
			};
		};
		Expr.find ["ID"] = function (id, context) {
			if (typeof context.getElementById! == "undefined" && documentIsHTML) {
				var elem = context.getElementById (id);
				trả lại elem? [elem]: [];
			}
		};
	} khác {
		Expr.filter ["ID"] = function (id) {
			var attrId = id.replace (runescape, funescape);
			hàm trả về (elem) {
				var node = typeof elem.getAttributeNode! == "undefined" &&
					elem.getAttributeNode ("id");
				trả về nút && node.value === attrId;
			};
		};

		// Hỗ trợ: chỉ IE 6-7
		// getElementById không đáng tin cậy như một lối tắt tìm
		Expr.find ["ID"] = function (id, context) {
			if (typeof context.getElementById! == "undefined" && documentIsHTML) {
				nút var, i, elems,
					elem = context.getElementById (id);

				if (elem) {

					// Xác minh thuộc tính id
					node = elem.getAttributeNode ("id");
					if (node ​​&& node.value === id) {
						trả về [elem];
					}

					// Quay lại getElementsByName
					elems = context.getElementsByName (id);
					i = 0;
					while ((elem = elems [i ++])) {
						node = elem.getAttributeNode ("id");
						if (node ​​&& node.value === id) {
							trả về [elem];
						}
					}
				}

				trở về [];
			}
		};
	}

	// Nhãn
	Expr.find ["TAG"] = support.getElementsByTagName?
		hàm (thẻ, ngữ cảnh) {
			if (typeof context.getElementsByTagName! == "undefined") {
				trả về context.getElementsByTagName (thẻ);

			// Các nút DocumentFragment không có gEBTN
			} else if (support.qsa) {
				trả về context.querySelectorAll (thẻ);
			}
		}:

		hàm (thẻ, ngữ cảnh) {
			var elem,
				tmp = [],
				i = 0,

				// Thật tình cờ, một gEBTN (bị hỏng) cũng xuất hiện trên các nút DocumentFragment
				results = context.getElementsByTagName (thẻ);

			// Lọc ra các bình luận có thể có
			if (thẻ === "*") {
				while ((elem = results [i ++])) {
					if (elem.nodeType === 1) {
						tmp.push (elem);
					}
				}

				trả lại tmp;
			}
			trả kết quả;
		};

	// Lớp
	Expr.find ["CLASS"] = support.getElementsByClassName && function (className, context) {
		if (typeof context.getElementsByClassName! == "undefined" && documentIsHTML) {
			trả về context.getElementsByClassName (className);
		}
	};

	/ * QSA / trận đấu
	-------------------------------------------------- -------------------- * /

	// Hỗ trợ QSA và trận đấu

	// MatchSelector (: active) báo cáo false khi true (IE9 / Opera 11.5)
	rbuggyMatches = [];

	// qSa (: focus) báo cáo false khi true (Chrome 21)
	// Chúng tôi cho phép điều này vì một lỗi trong IE8 / 9 gây ra lỗi
	// bất cứ khi nào `document.activeElement` được truy cập trên iframe
	// Vì vậy, chúng tôi cho phép: focus đi qua QSA mọi lúc để tránh lỗi IE
	// Xem https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ((support.qsa = rnative.test (document.querySelectorAll))) {

		// Xây dựng QSA regex
		// Chiến lược Regex được áp dụng từ Diego Perini
		khẳng định (hàm (el) {

			đầu vào var;

			// Chọn được đặt thành chuỗi trống có mục đích
			// Đây là để kiểm tra việc xử lý không rõ ràng của IE
			// thiết lập thuộc tính nội dung boolean,
			// vì sự hiện diện của nó là đủ
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild (el) .innerHTML = "<a id='" + expando + "'> </a>" +
				"<select id = '" + expando + "- \ r \\' msallowcapture = ''>" +
				"<option select = ''> </option> </select>";

			// Hỗ trợ: IE8, Opera 11-12.16
			// Không có gì nên được chọn khi các chuỗi trống theo sau ^ = hoặc $ = hoặc * =
			// Thuộc tính kiểm tra phải không xác định trong Opera nhưng "an toàn" cho WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if (el.querySelectorAll ("[msallowcapture ^ = '']") .length) {
				rbuggyQSA.push ("[* ^ $] =" + khoảng trắng + "* (?: '' | \" \ ")");
			}

			// Hỗ trợ: IE8
			// Thuộc tính boolean và "giá trị" không được xử lý chính xác
			if (! el.querySelectorAll ("[đã chọn]") .length) {
				rbuggyQSA.push ("\\ [" + khoảng trắng + "* (?: value |" + booleans + ")");
			}

			// Hỗ trợ: Chrome <29, Android <4.4, Safari <7.0+, iOS <7.0+, PhantomJS <1.9.8+
			if (! el.querySelectorAll ("[id ~ =" + expando + "-]") .length) {
				rbuggyQSA.push ("~ =");
			}

			// Hỗ trợ: IE 11+, Edge 15 - 18+
			// IE 11 / Edge không tìm thấy các phần tử trên truy vấn `[name = '']` trong một số trường hợp.
			// Thêm thuộc tính tạm thời vào tài liệu trước khi vùng chọn hoạt động
			// xung quanh vấn đề.
			// Thật thú vị, IE 10 trở lên dường như không gặp sự cố.
			input = document.createElement ("đầu vào");
			input.setAttribute ("tên", "");
			el.appendChild (đầu vào);
			if (! el.querySelectorAll ("[name = '']") .length) {
				rbuggyQSA.push ("\\ [" + khoảng trắng + "* tên" + khoảng trắng + "* =" +
					khoảng trắng + "* (?: '' | \" \ ")");
			}

			// Webkit / Opera -: được chọn sẽ trả về các phần tử tùy chọn đã chọn
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 ném lỗi ở đây và sẽ không thấy các bài kiểm tra sau này
			if (! el.querySelectorAll (": đã kiểm tra") .length) {
				rbuggyQSA.push (": đã kiểm tra");
			}

			// Hỗ trợ: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// Trong trang `selector # id Anh chị em-combinator selector` không thành công
			if (! el.querySelectorAll ("a #" + expando + "+ *") .length) {
				rbuggyQSA.push (". #. + [+ ~]");
			}

			// Chỉ hỗ trợ: Firefox <= 3.6 - 5
			// Firefox cũ không sử dụng mã nhận dạng không hợp lệ.
			el.querySelectorAll ("\\\ f");
			rbuggyQSA.push ("[\\ r \\ n \\ f]");
		});

		khẳng định (hàm (el) {
			el.innerHTML = "<a href='' disable='disabled'> </a>" +
				"<select disable = 'disable'> <option /> </select>";

			// Hỗ trợ: Ứng dụng gốc Windows 8
			// Thuộc tính kiểu và tên bị hạn chế trong quá trình gán .innerHTML
			var input = document.createElement ("input");
			input.setAttribute ("type", "hidden");
			el.appendChild (đầu vào) .setAttribute ("tên", "D");

			// Hỗ trợ: IE8
			// Thực thi phân biệt chữ hoa chữ thường của thuộc tính name
			if (el.querySelectorAll ("[name = d]") .length) {
				rbuggyQSA.push ("tên" + khoảng trắng + "* [* ^ $ |! ~]? =");
			}

			// FF 3.5 -: enable /: phần tử bị vô hiệu hóa và ẩn (phần tử ẩn vẫn được kích hoạt)
			// IE8 ném lỗi ở đây và sẽ không thấy các bài kiểm tra sau này
			if (el.querySelectorAll (": enable") .length! == 2) {
				rbuggyQSA.push (": đã bật", ": đã vô hiệu hóa");
			}

			// Hỗ trợ: IE9-11 +
			// IE's: bộ chọn bị vô hiệu hóa không chọn phần con của bộ trường bị vô hiệu hóa
			docElem.appendChild (el) .disabled = true;
			if (el.querySelectorAll (": vô hiệu hóa") .length! == 2) {
				rbuggyQSA.push (": đã bật", ": đã vô hiệu hóa");
			}

			// Hỗ trợ: Chỉ Opera 10 - 11
			// Opera 10-11 không ném vào các giả không hợp lệ sau dấu phẩy
			el.querySelectorAll ("*,: x");
			rbuggyQSA.push (",. *:");
		});
	}

	if ((support.matchesSelector = rnative.test ((so khớp = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector)))) {

		khẳng định (hàm (el) {

			// Kiểm tra xem liệu có thể thực hiện các trận đấu nối hay không
			// trên một nút bị ngắt kết nối (IE 9)
			support.disconnectedMatch = trận đấu.call (el, "*");

			// Điều này sẽ không thành công với một ngoại lệ
			// Gecko không bị lỗi, trả về false
			trận đấu.call (el, "[s! = '']: x");
			rbuggyMatches.push ("! =", pseudos);
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp (rbuggyQSA.join ("|"));
	rbuggyMatches = rbuggyMatches.length && new RegExp (rbuggyMatches.join ("|"));

	/* Chứa
	-------------------------------------------------- -------------------- * /
	hasCompare = rnative.test (docElem.compareDocumentPosition);

	// Phần tử chứa một phần tử khác
	// Có mục đích tự độc quyền
	// Như trong, một phần tử không chứa chính nó
	chứa = hasCompare || rnative.test (docElem.contains)?
		hàm (a, b) {
			var adown = a.nodeType === 9? a.documentElement: a,
				bup = b && b.parentNode;
			trả về a === bụp || !! (bup && bup.nodeType === 1 && (
				adown.contains?
					adown.contains (bup):
					a.compareDocumentPosition && a.compareDocumentPosition (bup) & 16
			));
		}:
		hàm (a, b) {
			nếu (b) {
				while ((b = b.parentNode)) {
					nếu (b === a) {
						trả về true;
					}
				}
			}
			trả về sai;
		};

	/ * Sắp xếp
	-------------------------------------------------- -------------------- * /

	// Sắp xếp thứ tự tài liệu
	sortOrder = hasCompare?
	hàm (a, b) {

		// Gắn cờ để xóa trùng lặp
		nếu (a === b) {
			hasDuplicate = true;
			trả về 0;
		}

		// Sắp xếp theo sự tồn tại của phương thức nếu chỉ một đầu vào có so sánhDocumentPosition
		var so sánh =! a.compareDocumentPosition -! b.compareDocumentPosition;
		if (so sánh) {
			trở lại so sánh;
		}

		// Tính toán vị trí nếu cả hai đầu vào thuộc cùng một tài liệu
		// Hỗ trợ: IE 11+, Edge 17 - 18+
		// IE / Edge đôi khi gặp lỗi "Quyền bị từ chối" khi so sánh chặt chẽ
		// hai tài liệu; so sánh nông cạn có tác dụng.
		// eslint-disable-next-line eqeqeq
		so sánh = (a.ownerDocument || a) == (b.ownerDocument || b)?
			a.compareDocumentPosition (b):

			// Nếu không, chúng tôi biết chúng đã bị ngắt kết nối
			1;

		// Các nút bị ngắt kết nối
		if (so sánh & 1 ||
			(! support.sortDetached && b.compareDocumentPosition (a) === so sánh)) {

			// Chọn phần tử đầu tiên có liên quan đến tài liệu ưa thích của chúng tôi
			// Hỗ trợ: IE 11+, Edge 17 - 18+
			// IE / Edge đôi khi gặp lỗi "Quyền bị từ chối" khi so sánh chặt chẽ
			// hai tài liệu; so sánh nông cạn có tác dụng.
			// eslint-disable-next-line eqeqeq
			if (a == document || a.ownerDocument == favouriteDoc &&
				chứa (ưa thíchDoc, a)) {
				trả về -1;
			}

			// Hỗ trợ: IE 11+, Edge 17 - 18+
			// IE / Edge đôi khi gặp lỗi "Quyền bị từ chối" khi so sánh chặt chẽ
			// hai tài liệu; so sánh nông cạn có tác dụng.
			// eslint-disable-next-line eqeqeq
			if (b == document || b.ownerDocument == favouriteDoc &&
				chứa (ưa thíchDoc, b)) {
				trả về 1;
			}

			// Duy trì thứ tự ban đầu
			trả về sortInput?
				(indexOf (sortInput, a) - indexOf (sortInput, b)):
				Số 0;
		}

		trở lại so sánh & 4? -1: 1;
	}:
	hàm (a, b) {

		// Thoát sớm nếu các nút giống hệt nhau
		nếu (a === b) {
			hasDuplicate = true;
			trả về 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [a],
			bp = [b];

		// Các nút không có cha mẹ là tài liệu hoặc bị ngắt kết nối
		if (! aup ||! bup) {

			// Hỗ trợ: IE 11+, Edge 17 - 18+
			// IE / Edge đôi khi gặp lỗi "Quyền bị từ chối" khi so sánh chặt chẽ
			// hai tài liệu; so sánh nông cạn có tác dụng.
			/ * eslint-disable eqeqeq * /
			trả về một tài liệu ==? -1:
				b == tài liệu? 1:
				/ * eslint-enable eqeqeq * /
				aup? -1:
				bụp? 1:
				sắp xếp đầu vào?
				(indexOf (sortInput, a) - indexOf (sortInput, b)):
				Số 0;

		// Nếu các nút là anh em ruột, chúng ta có thể kiểm tra nhanh
		} else if (aup === bup) {
			trả lại anh / chị / em-kiểm tra (a, b);
		}

		// Nếu không, chúng ta cần danh sách đầy đủ về tổ tiên của họ để so sánh
		cur = a;
		while ((cur = cur.parentNode)) {
			ap.unshift (cur);
		}
		cur = b;
		while ((cur = cur.parentNode)) {
			bp.unshift (cur);
		}

		// Đi bộ xuống cây để tìm sự khác biệt
		trong khi (ap [i] === bp [i]) {
			i ++;
		}

		trả lại tôi?

			// Thực hiện kiểm tra anh chị em xem các nút có chung tổ tiên không
			BrothersCheck (ap [i], bp [i]):

			// Nếu không, các nút trong tài liệu của chúng ta sắp xếp trước
			// Hỗ trợ: IE 11+, Edge 17 - 18+
			// IE / Edge đôi khi gặp lỗi "Quyền bị từ chối" khi so sánh chặt chẽ
			// hai tài liệu; so sánh nông cạn có tác dụng.
			/ * eslint-disable eqeqeq * /
			ap [i] ==Doc? -1:
			bp [i] ==Doc? 1:
			/ * eslint-enable eqeqeq * /
			Số 0;
	};

	trả lại tài liệu;
};

Sizzle.matches = function (expr, các phần tử) {
	return Sizzle (expr, null, null, các phần tử);
};

Sizzle.matchesSelector = function (elem, expr) {
	setDocument (elem);

	if (support.matchesSelector && documentIsHTML &&
		! nonnativeSelectorCache [expr + ""] &&
		(! rbuggyMatches ||! rbuggyMatches.test (expr)) &&
		(! rbuggyQSA ||! rbuggyQSA.test (expr))) {

		thử {
			var ret = trận đấu.call (elem, expr);

			// Các trận đấu của IE 9 trả về false trên các nút bị ngắt kết nối
			if (ret || support.disconnectedMatch ||

				// Ngoài ra, các nút bị ngắt kết nối được cho là nằm trong một tài liệu
				// phân mảnh trong IE 9
				elem.document && elem.document.nodeType! == 11) {
				trả lại ret;
			}
		} bắt (e) {
			nonnativeSelectorCache (expr, true);
		}
	}

	return Sizzle (expr, document, null, [elem]) .length> 0;
};

Sizzle.contains = function (context, elem) {

	// Đặt các ngăn tài liệu nếu cần
	// Hỗ trợ: IE 11+, Edge 17 - 18+
	// IE / Edge đôi khi gặp lỗi "Quyền bị từ chối" khi so sánh chặt chẽ
	// hai tài liệu; so sánh nông cạn có tác dụng.
	// eslint-disable-next-line eqeqeq
	if ((context.ownerDocument || context)! = document) {
		setDocument (ngữ cảnh);
	}
	return chứa (ngữ cảnh, elem);
};

Sizzle.attr = function (elem, name) {

	// Đặt các ngăn tài liệu nếu cần
	// Hỗ trợ: IE 11+, Edge 17 - 18+
	// IE / Edge đôi khi gặp lỗi "Quyền bị từ chối" khi so sánh chặt chẽ
	// hai tài liệu; so sánh nông cạn có tác dụng.
	// eslint-disable-next-line eqeqeq
	if ((elem.ownerDocument || elem)! = document) {
		setDocument (elem);
	}

	var fn = Expr.attrHandle [name.toLowerCase ()],

		// Đừng để bị lừa bởi các thuộc tính Object.prototype (jQuery # 13807)
		val = fn && hasOwn.call (Expr.attrHandle, name.toLowerCase ())?
			fn (elem, name,! documentIsHTML):
			không xác định;

	trả lại val! == không xác định?
		val:
		support.attributes || ! documentIsHTML?
			elem.getAttribute (tên):
			(val = elem.getAttributeNode (name)) && val.specified?
				val.value:
				vô giá trị;
};

Sizzle.escape = function (sel) {
	return (sel + "") .replace (rcssescape, fcssescape);
};

Sizzle.error = function (msg) {
	ném lỗi mới ("Lỗi cú pháp, biểu thức không nhận dạng được:" + msg);
};

/ **
 * Phân loại tài liệu và loại bỏ các bản sao
 * @param {ArrayLike} kết quả
 * /
Sizzle.uniqueSort = function (kết quả) {
	var elem,
		trùng lặp = [],
		j = 0,
		i = 0;

	// Trừ khi chúng ta * biết *, chúng ta có thể phát hiện các bản sao, hãy giả sử sự hiện diện của chúng
	hasDuplicate =! support.detectDuplicates;
	sortInput =! support.sortStable && results.slice (0);
	results.sort (Sắp xếp thứ tự);

	if (hasDuplicate) {
		while ((elem = results [i ++])) {
			if (elem === kết quả [i]) {
				j = trùng lặp.push (i);
			}
		}
		trong khi (j--) {
			results.splice (bản sao [j], 1);
		}
	}

	// Xóa đầu vào sau khi sắp xếp để giải phóng các đối tượng
	// Xem https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	trả kết quả;
};

/ **
 * Chức năng tiện ích để truy xuất giá trị văn bản của một mảng các nút DOM
 * @param {Array | Element} elem
 * /
getText = Sizzle.getText = function (elem) {
	nút var,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if (! nodeType) {

		// Nếu không có nodeType, đây được mong đợi là một mảng
		while ((node ​​= elem [i ++])) {

			// Không duyệt qua các nút bình luận
			ret + = getText (nút);
		}
	} else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {

		// Sử dụng textContent cho các phần tử
		// việc sử dụng innerText bị xóa để đảm bảo tính nhất quán của các dòng mới (jQuery # 11153)
		if (typeof elem.textContent === "string") {
			trả về elem.textContent;
		} khác {

			// Traverse con của nó
			cho (elem = elem.firstChild; elem; elem = elem.nextSibling) {
				ret + = getText (elem);
			}
		}
	} else if (nodeType === 3 || nodeType === 4) {
		trả về elem.nodeValue;
	}

	// Không bao gồm các nút nhận xét hoặc lệnh xử lý

	trả lại ret;
};

Expr = Sizzle.selectors = {

	// Người dùng có thể điều chỉnh
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	tìm thấy: {},

	liên quan đến: {
		">": {dir: "parentNode", first: true},
		"": {dir: "parentNode"},
		"+": {dir: "beforeSibling", first: true},
		"~": {dir: "beforeSibling"}
	},

	preFilter: {
		"ATTR": hàm (khớp) {
			match [1] = match [1] .replace (runescape, funescape);

			// Di chuyển giá trị đã cho để khớp với [3] dù được trích dẫn hay không được trích dẫn
			match [3] = (match [3] || match [4] ||
				trận đấu [5] || "") .replace (runescape, funescape);

			nếu (khớp [2] === "~ =") {
				match [3] = "" + match [3] + "";
			}

			return match.slice (0, 4);
		},

		"CON": function (match) {

			/ * đối sánh từ matchExpr ["CHILD"]
				1 loại (duy nhất | thứ | ...)
				2 cái gì (con | của loại)
				3 đối số (chẵn | lẻ | \ d * | \ d * n ([+ -] \ d +)? | ...)
				4 thành phần xn của đối số xn + y ([+ -]? \ D * n |)
				5 dấu hiệu của thành phần xn
				6 x của thành phần xn
				7 dấu hiệu của thành phần y
				8 y của thành phần y
			* /
			match [1] = match [1] .toLowerCase ();

			if (match [1] .slice (0, 3) === "nth") {

				// nth- * yêu cầu đối số
				if (! match [3]) {
					Sizzle.error (trận đấu [0]);
				}

				// tham số x và y số cho Expr.filter.CHILD
				// nhớ rằng false / true cast tương ứng thành 0/1
				match [4] = + (match [4]?
					match [5] + (match [6] || 1):
					2 * (khớp [3] === "chẵn" || khớp [3] === "lẻ"));
				trận [5] = + ((trận [7] + trận [8]) || trận [3] === "lẻ");

				// các loại khác cấm đối số
			} else if (khớp với [3]) {
				Sizzle.error (trận đấu [0]);
			}

			trận lượt về;
		},

		"PSEUDO": hàm (khớp) {
			var thừa,
				unquotes =! match [6] && match [2];

			if (matchExpr ["CHILD"] .test (match [0])) {
				trả về null;
			}

			// Chấp nhận các đối số được trích dẫn là-is
			nếu (khớp với [3]) {
				match [2] = match [4] || trận đấu [5] || "";

			// Loại bỏ các ký tự thừa khỏi các đối số không được trích dẫn
			} else if (chưa được trích dẫn && rpseudo.test (chưa được trích dẫn) &&

				// Lấy dư từ mã hóa (đệ quy)
				(quá mức = tokenize (không được trích dẫn, đúng)) &&

				// chuyển đến dấu ngoặc đóng tiếp theo
				{

				// vượt quá là một chỉ số âm
				match [0] = match [0] .slice (0, dư thừa);
				match [2] = unquoted.slice (0, dư thừa);
			}

			// Trả về chỉ các bản chụp cần thiết bởi phương thức bộ lọc giả (kiểu và đối số)
			return match.slice (0, 3);
		}
	},

	lọc: {

		"TAG": hàm (nodeNameSelector) {
			var nodeName = nodeNameSelector.replace (runescape, funescape) .toLowerCase ();
			trả về nodeNameSelector === "*"?
				hàm số() {
					trả về true;
				}:
				hàm (elem) {
					trả về elem.nodeName && elem.nodeName.toLowerCase () === nodeName;
				};
		},

		"CLASS": function (className) {
			var pattern = classCache [className + ""];

			mẫu trả về ||
				(pattern = new RegExp ("(^ |" + khoảng trắng +
					")" + className + "(" + khoảng trắng + "| $)")) && classCache (
						className, function (elem) {
							return pattern.test (
								typeof elem.className === "string" && elem.className ||
								typeof elem.getAttribute! == "không xác định" &&
									elem.getAttribute ("lớp") ||
								""
							);
				});
		},

		"ATTR": hàm (tên, toán tử, kiểm tra) {
			hàm trả về (elem) {
				var result = Sizzle.attr (elem, tên);

				if (result == null) {
					toán tử trả về === "! =";
				}
				toán tử if (!) {
					trả về true;
				}

				kết quả + = "";

				/ * eslint-disable max-len * /

				toán tử trả về === "="? kết quả === kiểm tra:
					toán tử === "! ="? kết quả! == kiểm tra:
					toán tử === "^ ="? check && result.indexOf (kiểm tra) === 0:
					toán tử === "* ="? check && result.indexOf (kiểm tra)> -1:
					toán tử === "$ ="? kiểm tra && result.slice (-check.length) === kiểm tra:
					toán tử === "~ ="? ("" + result.replace (rwhitespace, "") + "") .indexOf (kiểm tra)> -1:
					toán tử === "| ="? kết quả === kiểm tra || result.slice (0, check.length + 1) === check + "-":
					SAI;
				/ * eslint-enable max-len * /

			};
		},

		"CHILD": function (type, what, _argument, first, last) {
			var simple = type.slice (0, 3)! == "nth",
				forward = type.slice (-4)! == "cuối cùng",
				ofType = what === "thuộc loại";

			trả về đầu tiên === 1 && cuối cùng === 0?

				// Phím tắt cho: nth - * (n)
				hàm (elem) {
					return !! elem.parentNode;
				}:

				hàm (elem, _context, xml) {
					var cache, uniqueCache, externalCache, node, nodeIndex, start,
						dir = simple! == về phía trước? "nextSibling": "beforeSibling",
						cha mẹ = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase (),
						useCache =! xml &&! ofType,
						khác = sai;

					if (cha mẹ) {

						//: (đầu tiên | cuối cùng | chỉ) - (con | thuộc loại)
						if (đơn giản) {
							trong khi (dir) {
								nút = elem;
								while ((node ​​= node [dir])) {
									if (ofType?
										node.nodeName.toLowerCase () === tên:
										node.nodeType === 1) {

										trả về sai;
									}
								}

								// Đảo ngược hướng cho: only- * (nếu chúng ta chưa làm như vậy)
								start = dir = type === "only" &&! start && "nextSibling";
							}
							trả về true;
						}

						start = [chuyển tiếp? parent.firstChild: parent.lastChild];

						// non-xml: nth-child (...) lưu trữ dữ liệu bộ nhớ cache trên `cha`
						if (chuyển tiếp && useCache) {

							// Tìm kiếm `elem` từ một chỉ mục đã lưu trong bộ nhớ cache trước đó

							// ... theo cách thân thiện với gzip
							nút = cha mẹ;
							externalCache = node [expando] || (nút [expando] = {});

							// Hỗ trợ: chỉ IE <9
							// Bảo vệ chống lại các thuộc tính được sao chép (jQuery gh-1709)
							uniqueCache = externalCache [node.uniqueID] ||
								(externalCache [node.uniqueID] = {});

							cache = uniqueCache [type] || [];
							nodeIndex = cache [0] === dirruns && cache [1];
							diff = nodeIndex && cache [2];
							node = nodeIndex && parent.childNodes [nodeIndex];

							while ((node ​​= ++ nodeIndex && node && node [dir] ||

								// Dự phòng để tìm kiếm `elem` từ đầu
								(diff = nodeIndex = 0) || start.pop ())) {

								// Khi tìm thấy, lập chỉ mục bộ nhớ cache trên `cha` và ngắt
								if (node.nodeType === 1 && ++ diff && node === elem) {
									uniqueCache [type] = [dirruns, nodeIndex, diff];
									phá vỡ;
								}
							}

						} khác {

							// Sử dụng chỉ mục phần tử đã lưu trong bộ nhớ cache trước đó nếu có
							if (useCache) {

								// ... theo cách thân thiện với gzip
								nút = elem;
								externalCache = node [expando] || (nút [expando] = {});

								// Chỉ hỗ trợ: IE <9
								// Bảo vệ chống lại các thuộc tính được sao chép (jQuery gh-1709)
								uniqueCache = externalCache [node.uniqueID] ||
									(externalCache [node.uniqueID] = {});

								cache = uniqueCache [type] || [];
								nodeIndex = cache [0] === dirruns && cache [1];
								diff = nodeIndex;
							}

							// xml: nth-child (...)
							// hoặc: nth-last-child (...) hoặc: nth (-last)? - of-type (...)
							if (diff === false) {

								// Sử dụng vòng lặp tương tự như trên để tìm kiếm `elem` ngay từ đầu
								while ((node ​​= ++ nodeIndex && node && node [dir] ||
									(diff = nodeIndex = 0) || start.pop ())) {

									if ((ofType?
										node.nodeName.toLowerCase () === tên:
										node.nodeType === 1) &&
										++ khác) {

										// Lưu vào bộ nhớ cache chỉ mục của từng phần tử gặp phải
										if (useCache) {
											externalCache = node [expando] ||
												(nút [expando] = {});

											// Chỉ hỗ trợ: IE <9
											// Bảo vệ chống lại các thuộc tính được sao chép (jQuery gh-1709)
											uniqueCache = externalCache [node.uniqueID] ||
												(externalCache [node.uniqueID] = {});

											uniqueCache [type] = [dirruns, diff];
										}

										if (nút === elem) {
											phá vỡ;
										}
									}
								}
							}
						}

						// Kết hợp bù đắp, sau đó kiểm tra kích thước chu kỳ
						diff - = cuối cùng;
						trả về khác biệt === đầu tiên || (diff% đầu tiên === 0 && diff / first> = 0);
					}
				};
		},

		"PSEUDO": hàm (giả, đối số) {

			// tên lớp giả không phân biệt chữ hoa chữ thường
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Ưu tiên theo phân biệt chữ hoa chữ thường trong trường hợp các giả tùy chỉnh được thêm bằng chữ hoa
			// Hãy nhớ rằng setFilters kế thừa từ các giả
			var args,
				fn = Expr.pseudos [giả] || Expr.setFilters [pseudo.toLowerCase ()] ||
					Sizzle.error ("pseudo không được hỗ trợ:" + pseudo);

			// Người dùng có thể sử dụng createPseudo để chỉ ra rằng
			// các đối số là cần thiết để tạo hàm bộ lọc
			// giống như Sizzle
			if (fn [expando]) {
				return fn (đối số);
			}

			// Nhưng duy trì hỗ trợ cho các chữ ký cũ
			if (fn.length> 1) {
				args = [pseudo, pseudo, "", đối số];
				trả về Expr.setFilters.hasOwnProperty (pseudo.toLowerCase ())?
					markFunction (chức năng (hạt giống, kết quả phù hợp) {
						var idx,
							đã khớp = fn (hạt giống, đối số),
							i = match.length;
						trong khi tôi-- ) {
							idx = indexOf (hạt giống, đối sánh [i]);
							seed [idx] =! (match [idx] = match [i]);
						}
					}):
					hàm (elem) {
						return fn (elem, 0, args);
					};
			}

			trả về fn;
		}
	},

	giả: {

		// Các giả phức tạp tiềm ẩn
		"not": markFunction (chức năng (bộ chọn) {

			// Cắt bộ chọn được chuyển sang biên dịch
			// để tránh coi là đầu và cuối
			// khoảng trắng làm tổ hợp
			var input = [],
				kết quả = [],
				matcher = biên dịch (selector.replace (rtrim, "$ 1"));

			trả về đối sánh [expando]?
				markFunction (hàm (hạt giống, trận đấu, _context, xml) {
					var elem,
						chưa từng có = matcher (hạt giống, null, xml, []),
						i = seed.length;

					// Khớp các phần tử chưa được so khớp bởi `matcher`
					trong khi tôi-- ) {
						if ((elem = vô đối [i])) {
							seed [i] =! (so khớp [i] = elem);
						}
					}
				}):
				hàm (elem, _context, xml) {
					đầu vào [0] = elem;
					đối sánh (đầu vào, null, xml, kết quả);

					// Không giữ phần tử (sự cố # 299)
					input [0] = null;
					return! results.pop ();
				};
		}),

		"has": markFunction (chức năng (bộ chọn) {
			hàm trả về (elem) {
				return Sizzle (bộ chọn, độ cao) .length> 0;
			};
		}),

		"chứa": markFunction (chức năng (văn bản) {
			text = text.replace (runescape, funescape);
			hàm trả về (elem) {
				return (elem.textContent || getText (elem)) .indexOf (text)> -1;
			};
		}),

		// "Liệu một phần tử có được đại diện bởi bộ chọn: lang () hay không
		// chỉ dựa trên giá trị ngôn ngữ của phần tử
		// bằng với số nhận dạng C,
		// hoặc bắt đầu bằng số nhận dạng C, ngay sau đó là "-".
		// Việc so khớp C với giá trị ngôn ngữ của phần tử được thực hiện phân biệt chữ hoa chữ thường.
		// Định danh C không phải là tên ngôn ngữ hợp lệ. "
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction (function (lang) {

			// giá trị lang phải là một số nhận dạng hợp lệ
			if (! ridentifier.test (lang || "")) {
				Sizzle.error ("lang không được hỗ trợ:" + lang);
			}
			lang = lang.replace (runescape, funescape) .toLowerCase ();
			hàm trả về (elem) {
				var elemLang;
				làm {
					if ((elemLang = documentIsHTML?
						elem.lang:
						elem.getAttribute ("xml: lang") || elem.getAttribute ("lang"))) {

						elemLang = elemLang.toLowerCase ();
						trả về elemLang === lang || elemLang.indexOf (lang + "-") === 0;
					}
				} while ((elem = elem.parentNode) && elem.nodeType === 1);
				trả về sai;
			};
		}),

		// Điều khoản khác
		"target": function (elem) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice (1) === elem.id;
		},

		"root": function (elem) {
			trả về elem === docElem;
		},

		"tiêu điểm": function (elem) {
			trả về elem === document.activeElement &&
				(! document.hasFocus || document.hasFocus ()) &&
				!! (elem.type || elem.href || ~ elem.tabIndex);
		},

		// Thuộc tính boolean
		"đã bật": createDisabledPseudo (false),
		"vô hiệu hóa": createDisabledPseudo (true),

		"đã kiểm tra": function (elem) {

			// Trong CSS3,: check phải trả về cả phần tử đã chọn và đã chọn
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase ();
			return (nodeName === "input" && !! elem.checked) ||
				(nodeName === "option" && !! elem.selected);
		},

		"đã chọn": function (elem) {

			// Truy cập thuộc tính này làm cho được chọn theo mặc định
			// các tùy chọn trong Safari hoạt động bình thường
			if (elem.parentNode) {
				// eslint-disable-next-line no-used-expression
				elem.parentNode.selectedIndex;
			}

			trả về elem.selected === true;
		},

		// Nội dung
		"trống": function (elem) {

			// http://www.w3.org/TR/selectors/#empty-pseudo
			//: rỗng bị phủ định bởi phần tử (1) hoặc các nút nội dung (text: 3; cdata: 4; entity ref: 5),
			// nhưng không phải bởi những người khác (bình luận: 8; hướng dẫn xử lý: 7; v.v.)
			// nodeType <6 hoạt động vì các thuộc tính (2) không xuất hiện dưới dạng con
			cho (elem = elem.firstChild; elem; elem = elem.nextSibling) {
				if (elem.nodeType <6) {
					trả về sai;
				}
			}
			trả về true;
		},

		"cha": function (elem) {
			return! expr.pseudos ["trống"] (elem);
		},

		// Loại phần tử / đầu vào
		"tiêu đề": function (elem) {
			trả về rheader.test (elem.nodeName);
		},

		"input": function (elem) {
			trả về rinputs.test (elem.nodeName);
		},

		"button": function (elem) {
			var name = elem.nodeName.toLowerCase ();
			trả về tên === "đầu vào" && elem.type === "nút" || tên === "nút";
		},

		"text": function (elem) {
			var attr;
			trả về elem.nodeName.toLowerCase () === "đầu vào" &&
				elem.type === "văn bản" &&

				// Hỗ trợ: IE <8
				// Các giá trị thuộc tính HTML5 mới (ví dụ: "tìm kiếm") xuất hiện với elem.type === "text"
				((attr = elem.getAttribute ("type")) == null ||
					attr.toLowerCase () === "văn bản");
		},

		// Vị trí trong bộ sưu tập
		"đầu tiên": createPositionalPseudo (function () {
			return [0];
		}),

		"cuối cùng": createPositionalPseudo (function (_matchIndexes, length) {
			return [chiều dài - 1];
		}),

		"eq": createPositionalPseudo (function (_matchIndexes, length, đối số) {
			return [đối số <0? đối số + độ dài: đối số];
		}),

		"Even": createPositionalPseudo (function (matchIndexes, length) {
			var i = 0;
			for (; i <length; i + = 2) {
				matchIndexes.push (i);
			}
			return matchIndexes;
		}),

		"lẻ": createPositionalPseudo (function (matchIndexes, length) {
			var i = 1;
			for (; i <length; i + = 2) {
				matchIndexes.push (i);
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo (function (matchIndexes, length, đối số) {
			var i = đối số <0?
				đối số + độ dài:
				đối số> độ dài?
					chiều dài :
					lý lẽ;
			cho (; --i> = 0;) {
				matchIndexes.push (i);
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo (function (matchIndexes, length, đối số) {
			var i = đối số <0? đối số + độ dài: đối số;
			for (; ++ i <length;) {
				matchIndexes.push (i);
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos ["nth"] = Expr.pseudos ["eq"];

// Thêm nút / giả kiểu đầu vào
for (tôi trong {radio: true, checkbox: true, file: true, password: true, image: true}) {
	Expr.pseudos [i] = createInputPseudo (i);
}
cho (tôi trong {submit: true, reset: true}) {
	Expr.pseudos [i] = createButtonPseudo (i);
}

// API dễ dàng để tạo setFilters mới
function setFilters () {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters ();

tokenize = Sizzle.tokenize = function (selector, parseOnly) {
	var đối sánh, đối sánh, mã thông báo, loại,
		soFar, nhóm, preFilters,
		cache = tokenCache [selector + ""];

	if (được lưu trong bộ nhớ cache) {
		trả về parseOnly? 0: cache.slice (0);
	}

	soFar = bộ chọn;
	nhóm = [];
	preFilters = Expr.preFilter;

	trong khi (soFar) {

		// Dấu phẩy và lần chạy đầu tiên
		if (! match || (match = rcomma.exec (soFar))) {
			nếu (khớp) {

				// Không sử dụng dấu phẩy ở cuối là hợp lệ
				soFar = soFar.slice (so khớp [0] .length) || cho đến nay;
			}
			groups.push ((mã thông báo = []));
		}

		phù hợp = sai;

		// Kết hợp
		if ((match = rcombinators.exec (soFar))) {
			match = match.shift ();
			tokens.push ({
				giá trị: phù hợp,

				// Truyền các tổ hợp con cháu vào không gian
				type: match [0] .replace (rtrim, "")
			});
			soFar = soFar.slice (match.length);
		}

		// Bộ lọc
		for (nhập Expr.filter) {
			if ((match = matchExpr [type] .exec (soFar)) && (! preFilters [type] ||
				(match = preFilters [type] (match)))) {
				match = match.shift ();
				tokens.push ({
					giá trị: phù hợp,
					type: loại,
					trận đấu: trận đấu
				});
				soFar = soFar.slice (match.length);
			}
		}

		if (! khớp) {
			phá vỡ;
		}
	}

	// Trả về độ dài của phần vượt quá không hợp lệ
	// nếu chúng ta chỉ phân tích cú pháp
	// Nếu không, hãy tạo ra một lỗi hoặc trả về các mã thông báo
	trả về parseOnly ?
		soFar.length:
		cho đến nay ?
			Sizzle.error (bộ chọn):

			// Lưu vào bộ nhớ cache các mã thông báo
			tokenCache (bộ chọn, nhóm) .slice (0);
};

function toSelector (mã thông báo) {
	var i = 0,
		len = tokens.length,
		bộ chọn = "";
	for (; i <len; i ++) {
		bộ chọn + = tokens [i] .value;
	}
	bộ chọn trở lại;
}

function addCombinator (so khớp, tổ hợp, cơ sở) {
	var dir = combinator.dir,
		bỏ qua = combinator.next,
		key = bỏ qua || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done ++;

	trả về combinator.first?

		// Kiểm tra phần tử tổ tiên / trước gần nhất
		function (elem, context, xml) {
			trong khi ((elem = elem [dir])) {
				if (elem.nodeType === 1 || checkNonElements) {
					trả về đối sánh (elem, ngữ cảnh, xml);
				}
			}
			trả về sai;
		}:

		// Kiểm tra tất cả các phần tử tổ tiên / trước
		function (elem, context, xml) {
			var oldCache, uniqueCache, externalCache,
				newCache = [dirruns, doneName];

			// Chúng tôi không thể đặt dữ liệu tùy ý trên các nút XML, vì vậy chúng không được hưởng lợi từ bộ nhớ đệm tổ hợp
			if (xml) {
				trong khi ((elem = elem [dir])) {
					if (elem.nodeType === 1 || checkNonElements) {
						if (so khớp (elem, context, xml)) {
							trả về true;
						}
					}
				}
			} khác {
				trong khi ((elem = elem [dir])) {
					if (elem.nodeType === 1 || checkNonElements) {
						externalCache = elem [expando] || (elem [expando] = {});

						// Chỉ hỗ trợ: IE <9
						// Bảo vệ chống lại các thuộc tính được sao chép (jQuery gh-1709)
						uniqueCache = externalCache [elem.uniqueID] ||
							(externalCache [elem.uniqueID] = {});

						if (bỏ qua && bỏ qua === elem.nodeName.toLowerCase ()) {
							elem = elem [dir] || độ cao;
						} else if ((oldCache = uniqueCache [key]) &&
							oldCache [0] === dirruns && oldCache [1] === doneName) {

							// Gán cho newCache để kết quả truyền ngược lại cho các phần tử trước đó
							return (newCache [2] = oldCache [2]);
						} khác {

							// Sử dụng lại newcache để kết quả truyền ngược trở lại các phần tử trước đó
							uniqueCache [key] = newCache;

							// Một trận đấu có nghĩa là chúng ta đã hoàn tất; thất bại có nghĩa là chúng ta phải tiếp tục kiểm tra
							if ((newCache [2] = matcher (elem, context, xml))) {
								trả về true;
							}
						}
					}
				}
			}
			trả về sai;
		};
}

function elementMatcher (đối sánh) {
	trả về matchers.length> 1?
		function (elem, context, xml) {
			var i = matchers.length;
			trong khi tôi-- ) {
				if (! matchers [i] (elem, context, xml)) {
					trả về sai;
				}
			}
			trả về true;
		}:
		người đối sánh [0];
}

function multipleContexts (bộ chọn, ngữ cảnh, kết quả) {
	var i = 0,
		len = contextxts.length;
	for (; i <len; i ++) {
		Sizzle (bộ chọn, ngữ cảnh [i], kết quả);
	}
	trả kết quả;
}

hàm ngưng tụ (chưa đối sánh, bản đồ, bộ lọc, ngữ cảnh, xml) {
	var elem,
		newUnmished = [],
		i = 0,
		len = chưa khớp.length,
		mapped = map! = null;

	for (; i <len; i ++) {
		if ((elem = vô đối [i])) {
			if (! filter || filter (elem, context, xml)) {
				newUnmished.push (elem);
				nếu (được ánh xạ) {
					map.push (i);
				}
			}
		}
	}

	trả về mới
}

function setMatcher (preFilter, selector, matcher, postFilter, postFinder, postSelector) {
	if (postFilter &&! postFilter [expando]) {
		postFilter = setMatcher (postFilter);
	}
	if (postFinder &&! postFinder [expando]) {
		postFinder = setMatcher (postFinder, postSelector);
	}
	trả về markFunction (hàm (hạt giống, kết quả, ngữ cảnh, xml) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Lấy các phần tử ban đầu từ hạt giống hoặc ngữ cảnh
			elems = hạt giống || multiContexts (
				bộ chọn || "*",
				context.nodeType? [context]: bối cảnh,
				[]
			),

			// Bộ lọc trước để nhận đầu vào của trình so khớp, giữ lại bản đồ để đồng bộ hóa kết quả hạt giống
			matcherIn = preFilter && (seed ||! selector)?
				ngưng tụ (elems, preMap, preFilter, context, xml):
				elems,

			matcherOut = người kết hợp?

				// Nếu chúng ta có postFinder, hoặc hạt giống đã lọc, hoặc postFilter không phải hạt giống hoặc các kết quả có sẵn,
				postFinder || (seed? preFilter: preexisting || postFilter)?

					// ... xử lý trung gian là cần thiết
					[]:

					// ... nếu không thì sử dụng kết quả trực tiếp
					các kết quả :
				matcherIn;

		// Tìm kết quả phù hợp chính
		if (đối sánh) {
			matcher (matcherIn, matcherOut, context, xml);
		}

		// Áp dụng postFilter
		if (postFilter) {
			temp = ngưng tụ (matcherOut, postMap);
			postFilter (temp, [], context, xml);

			// Bỏ đối sánh các phần tử không thành công bằng cách chuyển chúng trở lại matcherIn
			i = temp.length;
			trong khi tôi-- ) {
				if ((elem = temp [i])) {
					matcherOut [postMap [i]] =! (matcherIn [postMap [i]] = elem);
				}
			}
		}

		nếu (hạt giống) {
			if (postFinder || preFilter) {
				if (postFinder) {

					// Lấy matcherOut cuối cùng bằng cách ngưng tụ trung gian này vào ngữ cảnh postFinder
					tạm = [];
					i = matcherOut.length;
					trong khi tôi-- ) {
						if ((elem = matcherOut [i])) {

							// Khôi phục matcherIn vì elem chưa phải là trận đấu cuối cùng
							temp.push ((matcherIn [i] = elem));
						}
					}
					postFinder (null, (matcherOut = []), tạm thời, xml);
				}

				// Di chuyển các phần tử phù hợp từ hạt giống đến kết quả để giữ cho chúng được đồng bộ hóa
				i = matcherOut.length;
				trong khi tôi-- ) {
					if ((elem = matcherOut [i]) &&
						(temp = postFinder? indexOf (seed, elem): preMap [i])> -1) {

						seed [temp] =! (results [temp] = elem);
					}
				}
			}

		// Thêm các phần tử vào kết quả, thông qua postFinder nếu được xác định
		} khác {
			matcherOut = ngưng tụ (
				matcherOut === kết quả?
					matcherOut.splice (tồn tại trước, matcherOut.length):
					matcherOut
			);
			if (postFinder) {
				postFinder (null, kết quả, matcherOut, xml);
			} khác {
				push.apply (kết quả, matcherOut);
			}
		}
	});
}

function matcherFromTokens (mã thông báo) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadRelative = Expr.relative [mã thông báo [0] .type],
		implicitRelative = hàng đầuRelative || Tương quan [""],
		i = leadRelative? 1: 0,

		// Trình so khớp nền tảng đảm bảo rằng các phần tử có thể truy cập được từ (các) ngữ cảnh cấp cao nhất
		matchContext = addCombinator (function (elem) {
			trả về elem === checkContext;
		}, implicitRelative, true),
		matchAnyContext = addCombinator (function (elem) {
			trả về indexOf (checkContext, elem)> -1;
		}, implicitRelative, true),
		matchers = [function (elem, context, xml) {
			var ret = (! leadRelative && (xml || context! == ngoài cùngContext)) || (
				(checkContext = context) .nodeType?
					matchContext (elem, context, xml):
					matchAnyContext (elem, context, xml));

			// Tránh bám vào phần tử (sự cố # 299)
			checkContext = null;
			trả lại ret;
		}];

	for (; i <len; i ++) {
		if ((matcher = Expr.relative [tokens [i] .type])) {
			matchers = [addCombinator (elementMatcher (đối sánh), đối sánh)];
		} khác {
			matcher = Expr.filter [tokens [i] .type] .apply (null, tokens [i] .matches);

			// Trả lại đặc biệt khi nhìn thấy một đối sánh vị trí
			nếu (đối sánh [expando]) {

				// Tìm toán tử tương đối tiếp theo (nếu có) để xử lý thích hợp
				j = ++ i;
				for (; j <len; j ++) {
					if (Expr.relative [tokens [j] .type]) {
						phá vỡ;
					}
				}
				trả về setMatcher (
					i> 1 && elementMatcher (đối sánh),
					i> 1 && toSelector (

					// Nếu mã thông báo trước là một tổ hợp con, hãy chèn một phần tử bất kỳ tiềm ẩn `* '
					mã thông báo
						.slice (0, i - 1)
						.concat ({value: tokens [i - 2] .type === ""? "*": ""})
					) .replace (rtrim, "$ 1"),
					người kết hợp,
					i <j && matcherFromTokens (tokens.slice (i, j)),
					j <len && matcherFromTokens ((tokens = tokens.slice (j))),
					j <len && toSelector (mã thông báo)
				);
			}
			matchers.push (đối sánh);
		}
	}

	return elementMatcher (đối sánh);
}

function matcherFromGroupMatchers (elementMatchers, setMatchers) {
	var bySet = setMatchers.length> 0,
		byElement = elementMatchers.length> 0,
		superMatcher = function (hạt giống, ngữ cảnh, xml, kết quả, ngoài cùng) {
			var elem, j, matcher,
				matchCount = 0,
				i = "0",
				vô đối = hạt giống && [],
				setM match = [],
				contextBackup = ngoài cùngContext,

				// Chúng ta phải luôn có các phần tử hạt giống hoặc ngữ cảnh ngoài cùng
				elems = hạt giống || byElement && Expr.find ["TAG"] ("*", ngoài cùng),

				// Sử dụng số nguyên dirruns iff đây là trình đối sánh ngoài cùng
				dirrunsUnique = (dirruns + = contextBackup == null? 1: Math.random () || 0,1),
				len = elems.length;

			if (ngoài cùng) {

				// Hỗ trợ: IE 11+, Edge 17 - 18+
				// IE / Edge đôi khi gặp lỗi "Quyền bị từ chối" khi so sánh chặt chẽ
				// hai tài liệu; so sánh nông cạn có tác dụng.
				// eslint-disable-next-line eqeqeq
				ngoài cùngContext = context == document || bối cảnh || ngoài cùng;
			}

			// Thêm các phần tử chuyển trực tiếp elementMatchers vào kết quả
			// Hỗ trợ: IE <9, Safari
			// Dung sai các thuộc tính NodeList (IE: "length"; Safari: <number>) khớp các phần tử theo id
			for (; i! == len && (elem = elems [i])! = null; i ++) {
				if (byElement && elem) {
					j = 0;

					// Hỗ trợ: IE 11+, Edge 17 - 18+
					// IE / Edge đôi khi gặp lỗi "Quyền bị từ chối" khi so sánh chặt chẽ
					// hai tài liệu; so sánh nông cạn có tác dụng.
					// eslint-disable-next-line eqeqeq
					if (! context && elem.ownerDocument! = document) {
						setDocument (elem);
						xml =! documentIsHTML;
					}
					while ((matcher = elementMatchers [j ++])) {
						if (so khớp (elem, context || document, xml)) {
							results.push (elem);
							phá vỡ;
						}
					}
					if (ngoài cùng) {
						dirruns = dirrunsUnique;
					}
				}

				// Theo dõi các phần tử chưa được so khớp cho các bộ lọc đã đặt
				if (bySet) {

					// Họ sẽ trải qua tất cả những người so khớp có thể có
					if ((elem =! matcher && elem)) {
						Đã đối sánh--;
					}

					// Kéo dài mảng cho mọi phần tử, có khớp hay không
					nếu (hạt giống) {
						vô đối.push (elem);
					}
				}
			}

			// `i` bây giờ là số phần tử được truy cập ở trên và thêm nó vào` matchCount`
			// làm cho cái sau không âm.
			matchCount + = i;

			// Áp dụng bộ lọc tập hợp cho các phần tử chưa được so khớp
			// LƯU Ý: Có thể bỏ qua điều này nếu không có phần tử nào chưa được so khớp (ví dụ: `matchCount`
			// bằng `i`), trừ khi chúng ta không truy cập các phần tử _any_ trong vòng lặp trên vì chúng ta có
			// không có trình đối sánh phần tử và không có hạt giống.
			// Tăng chuỗi ban đầu "0" `i` cho phép` i` chỉ còn là một chuỗi trong đó
			// trường hợp, sẽ dẫn đến một "00" `matchCount` khác với` i` nhưng cũng là
			// số không.
			if (bySet && i! == matchCount) {
				j = 0;
				while ((matcher = setMatchers [j ++])) {
					matcher (chưa khớp, setM phù hợp, ngữ cảnh, xml);
				}

				nếu (hạt giống) {

					// Tích hợp lại các kết quả phù hợp phần tử để loại bỏ nhu cầu sắp xếp
					if (MatchCount> 0) {
						trong khi tôi-- ) {
							if (! (vô đối [i] || setM match [i])) {
								setM match [i] = pop.call (kết quả);
							}
						}
					}

					// Loại bỏ các giá trị trình giữ chỗ chỉ mục để chỉ nhận các kết quả phù hợp thực tế
					setM Match = ngưng tụ (setM Match);
				}

				// Thêm kết quả phù hợp vào kết quả
				push.apply (kết quả, setM match);

				// Đối sánh tập hợp không hạt giống thành công nhiều đối sánh thành công quy định sắp xếp
				if (ngoài cùng &&! seed && setMished.length> 0 &&
					(matchCount + setMatchers.length)> 1) {

					Sizzle.uniqueSort (kết quả);
				}
			}

			// Ghi đè thao tác trên toàn cầu bằng các trình đối sánh lồng nhau
			if (ngoài cùng) {
				dirruns = dirrunsUnique;
				ngoài cùngContext = contextBackup;
			}

			trở lại vô đối;
		};

	trả lại bySet?
		markFunction (superMatcher):
		superMatcher;
}

compile = Sizzle.compile = function (selector, match / * Chỉ sử dụng nội bộ * /) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cache = compilerCache [selector + ""];

	if (! cache) {

		// Tạo một hàm đệ quy có thể được sử dụng để kiểm tra từng phần tử
		if (! match) {
			match = tokenize (bộ chọn);
		}
		i = match.length;
		trong khi tôi-- ) {
			cache = matcherFromTokens (match [i]);
			if (cache [expando]) {
				setMatchers.push (đã lưu trong bộ nhớ đệm);
			} khác {
				elementMatchers.push (được lưu trong bộ nhớ đệm);
			}
		}

		// Lưu vào bộ nhớ cache của hàm đã biên dịch
		cache = compilerCache (
			bộ chọn,
			matcherFromGroupMatchers (elementMatchers, setMatchers)
		);

		// Lưu bộ chọn và mã hóa
		cache.selector = bộ chọn;
	}
	trả về bộ nhớ đệm;
};

/ **
 * Chức năng lựa chọn cấp thấp hoạt động với trình biên dịch của Sizzle
 * chức năng bộ chọn
 * Bộ chọn @param {String | Function} Một bộ chọn hoặc biên dịch trước
 * chức năng bộ chọn được xây dựng với Sizzle.compile
 * @param {Element} ngữ cảnh
 * @param {Array} [kết quả]
 * @param {Array} [seed] Một tập hợp các phần tử để so khớp
 * /
select = Sizzle.select = function (selector, context, results, seed) {
	var i, mã thông báo, mã thông báo, loại, tìm,
		biên dịch = typeof selector === "function" && selector,
		match =! seed && tokenize ((selector = biên dịch.selector || selector));

	results = kết quả || [];

	// Cố gắng giảm thiểu các thao tác nếu chỉ có một bộ chọn trong danh sách và không có hạt giống
	// (cái sau đảm bảo cho chúng ta ngữ cảnh)
	if (match.length === 1) {

		// Giảm ngữ cảnh nếu bộ chọn ghép hàng đầu là một ID
		tokens = match [0] = match [0] .slice (0);
		if (tokens.length> 2 && (token = tokens [0]) .type === "ID" &&
			context.nodeType === 9 && documentIsHTML && Expr.relative [mã thông báo [1] .type]) {

			context = (Expr.find ["ID"] (token.matches [0]
				.replace (runescape, funescape), context) || []) [0];
			if (! context) {
				trả kết quả;

			// Các trình đối sánh được biên dịch trước vẫn sẽ xác minh tổ tiên, vì vậy hãy nâng cấp lên một cấp độ
			} else if (biên dịch) {
				context = context.parentNode;
			}

			selector = selector.slice (tokens.shift (). value.length);
		}

		// Tìm nạp một tập hợp hạt giống để đối sánh từ phải sang trái
		i = matchExpr ["needContext"] .test (bộ chọn)? 0: tokens.length;
		trong khi tôi-- ) {
			mã thông báo = tokens [i];

			// Hủy bỏ nếu chúng ta nhấn một tổ hợp
			if (Expr.relative [(type = token.type)]) {
				phá vỡ;
			}
			if ((find = Expr.find [type])) {

				// Tìm kiếm, mở rộng ngữ cảnh cho các tổ hợp anh chị em hàng đầu
				if ((seed = find (
					token.matches [0] .replace (runescape, funescape),
					rsibling.test (mã thông báo [0] .type) && testContext (context.parentNode) ||
						bối cảnh
				))) {

					// Nếu hạt giống trống hoặc không còn mã thông báo, chúng tôi có thể quay lại sớm
					tokens.splice (i, 1);
					selector = seed.length && toSelector (mã thông báo);
					if (! selector) {
						push.apply (kết quả, hạt giống);
						trả kết quả;
					}

					phá vỡ;
				}
			}
		}
	}

	// Biên dịch và thực thi một hàm lọc nếu một hàm không được cung cấp
	// Cung cấp `match` để tránh trang bị lại nếu chúng tôi đã sửa đổi bộ chọn ở trên
	(biên dịch || biên dịch (bộ chọn, kết hợp)) (
		hạt giống,
		bối cảnh,
		! documentIsHTML,
		các kết quả,
		! ngữ cảnh || rsibling.test (bộ chọn) && testContext (context.parentNode) || bối cảnh
	);
	trả kết quả;
};

// Bài tập một lần

// Sắp xếp ổn định
support.sortStable = expando.split ("") .sort (sortOrder) .join ("") === expando;

// Hỗ trợ: Chrome 14-35 +
// Luôn giả sử các bản sao nếu chúng không được chuyển đến hàm so sánh
support.detectDuplicates = !! hasDuplicate;

// Khởi tạo với tài liệu mặc định
setDocument ();

// Hỗ trợ: Webkit <537.32 - Safari 6.0.3 / Chrome 25 (đã sửa trong Chrome 27)
// Các nút tách rời theo dõi một cách khó hiểu * lẫn nhau *
support.sortDetached = khẳng định (function (el) {

	// Nên trả về 1, nhưng trả về 4 (đang theo dõi)
	return el.compareDocumentPosition (document.createElement ("fieldset")) & 1;
});

// Hỗ trợ: IE <8
// Ngăn thuộc tính / thuộc tính "nội suy"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if (! khẳng định (function (el) {
	el.innerHTML = "<a href='#'> </a>";
	return el.firstChild.getAttribute ("href") === "#";
})) {
	addHandle ("type | href | height | width", function (elem, name, isXML) {
		if (! isXML) {
			return elem.getAttribute (name, name.toLowerCase () === "type"? 1: 2);
		}
	});
}

// Hỗ trợ: IE <9
// Sử dụng defaultValue thay cho getAttribute ("giá trị")
if (! support.attributes ||! khẳng định (function (el) {
	el.innerHTML = "<input />";
	el.firstChild.setAttribute ("giá trị", "");
	return el.firstChild.getAttribute ("giá trị") === "";
})) {
	addHandle ("giá trị", hàm (elem, _name, isXML) {
		if (! isXML && elem.nodeName.toLowerCase () === "input") {
			trả về elem.defaultValue;
		}
	});
}

// Hỗ trợ: IE <9
// Sử dụng getAttributeNode để tìm nạp boolean khi getAttribute nói dối
if (! khẳng định (function (el) {
	return el.getAttribute ("bị vô hiệu hóa") == null;
})) {
	addHandle (booleans, function (elem, name, isXML) {
		var val;
		if (! isXML) {
			trả về elem [name] === true? name.toLowerCase ():
				(val = elem.getAttributeNode (name)) && val.specified?
					val.value:
					vô giá trị;
		}
	});
}

trở lại Sizzle;

} )( cửa sổ );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Không được dùng nữa
jQuery.expr [":"] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function (elem, dir, cho đến khi) {
	var match = [],
		truncate = cho đến khi! == không xác định;

	while ((elem = elem [dir]) && elem.nodeType! == 9) {
		if (elem.nodeType === 1) {
			if (cắt ngắn && jQuery (elem) .is (cho đến khi)) {
				phá vỡ;
			}
			phù hợp.push (elem);
		}
	}
	trả về phù hợp;
};


var anh chị em = function (n, elem) {
	var phù hợp = [];

	cho (; n; n = n.nextSibling) {
		if (n.nodeType === 1 && n! == elem) {
			phù hợp.push (n);
		}
	}

	trả về phù hợp;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName (elem, name) {

  trả về elem.nodeName && elem.nodeName.toLowerCase () === name.toLowerCase ();

};
var rsingleTag = (/ ^ <([az] [^ \ / \ 0>: \ x20 \ t \ r \ n \ f] *) [\ x20 \ t \ r \ n \ f] * \ /?> ( ?: <\ / \ 1> |) $ / i);



// Triển khai chức năng giống hệt nhau cho bộ lọc và không
function winnow (các phần tử, định nghĩa, không phải) {
	if (isFunction (định nghĩa)) {
		trả về jQuery.grep (các phần tử, hàm (elem, i) {
			return !! quality.call (elem, i, elem)! == not;
		});
	}

	// Phần tử đơn
	if (evalfier.nodeType) {
		trả về jQuery.grep (các phần tử, hàm (elem) {
			return (vòng loại elem ===)! == not;
		});
	}

	// Giống mảng của các phần tử (jQuery, các đối số, Mảng)
	if (định nghĩa typeof! == "string") {
		trả về jQuery.grep (các phần tử, hàm (elem) {
			return (indexOf.call (vòng loại, elem)> -1)! == not;
		});
	}

	// Được lọc trực tiếp cho cả bộ chọn đơn giản và phức tạp
	return jQuery.filter (định tính, các phần tử, không phải);
}

jQuery.filter = function (expr, elems, not) {
	var elem = elems [0];

	nếu không ) {
		expr = ": not (" + expr + ")";
	}

	if (elems.length === 1 && elem.nodeType === 1) {
		trả về jQuery.find.matchesSelector (elem, expr)? [elem]: [];
	}

	trả về jQuery.find.matches (expr, jQuery.grep (elems, function (elem) {
		trả về elem.nodeType === 1;
	}));
};

jQuery.fn.extend ({
	find: function (selector) {
		var i, ret,
			len = this.length,
			tự = cái này;

		if (typeof selector! == "string") {
			return this.pushStack (jQuery (selector) .filter (function () {
				for (i = 0; i <len; i ++) {
					if (jQuery.contains (self [i], this)) {
						trả về true;
					}
				}
			}));
		}

		ret = this.pushStack ([]);

		for (i = 0; i <len; i ++) {
			jQuery.find (selector, self [i], ret);
		}

		return len> 1? jQuery.uniqueSort (ret): ret;
	},
	filter: function (selector) {
		return this.pushStack (winnow (this, selector || [], false));
	},
	not: function (selector) {
		return this.pushStack (winnow (this, selector || [], true));
	},
	is: function (selector) {
		trở lại !! winnow (
			cái này,

			// Nếu đây là bộ chọn vị trí / tương đối, hãy kiểm tra tư cách thành viên trong tập hợp được trả về
			// vì vậy $ ("p: first"). is ("p: last") sẽ không trả về true cho tài liệu có hai "p".
			typeof selector === "string" && rneedsContext.test (selector)?
				jQuery (bộ chọn):
				bộ chọn || [],
			SAI
		).chiều dài;
	}
});


// Khởi tạo một đối tượng jQuery


// Tham chiếu trung tâm đến jQuery gốc (tài liệu)
var rootjQuery,

	// Một cách đơn giản để kiểm tra các chuỗi HTML
	// Ưu tiên #id hơn <tag> để tránh XSS qua location.hash (# 9521)
	// Nhận dạng HTML nghiêm ngặt (# 11290: phải bắt đầu bằng <)
	// Phím tắt đơn giản trong trường hợp #id cho tốc độ
	rquickExpr = / ^ (?: \ s * (<[\ w \ W] +>) [^>] * | # ([\ w -] +)) $ /,

	init = jQuery.fn.init = function (selector, context, root) {
		trận đấu var, elem;

		// XỬ LÝ: $ (""), $ (null), $ (không xác định), $ (sai)
		if (! selector) {
			trả lại cái này;
		}

		// Phương thức init () chấp nhận một rootjQuery thay thế
		// để di chuyển có thể hỗ trợ jQuery.sub (gh-2101)
		root = gốc || rootjQuery;

		// Xử lý các chuỗi HTML
		if (typeof selector === "string") {
			if (selector [0] === "<" &&
				bộ chọn [selector.length - 1] === ">" &&
				selector.length> = 3) {

				// Giả sử rằng các chuỗi bắt đầu và kết thúc bằng <> là HTML và bỏ qua kiểm tra regex
				khớp = [null, bộ chọn, null];

			} khác {
				match = rquickExpr.exec (bộ chọn);
			}

			// Khớp với html hoặc đảm bảo không có ngữ cảnh nào được chỉ định cho #id
			if (match && (match [1] ||! context)) {

				// XỬ LÝ: $ (html) -> $ (mảng)
				nếu (khớp với [1]) {
					context = context instanceof jQuery? context [0]: bối cảnh;

					// Tùy chọn chạy script đúng với back-compat
					// Cố tình để xảy ra lỗi nếu không có parseHTML
					jQuery.merge (this, jQuery.parseHTML (
						khớp với [1],
						context && context.nodeType? context.ownerDocument || ngữ cảnh: tài liệu,
						THÀNH THẬT
					));

					// XỬ LÝ: $ (html, props)
					if (rsingleTag.test (match [1]) && jQuery.isPlainObject (context)) {
						for (phù hợp với ngữ cảnh) {

							// Thuộc tính của ngữ cảnh được gọi là phương thức nếu có thể
							if (isFunction (this [match])) {
								this [trận đấu] (ngữ cảnh [trận đấu]);

							// ... và nếu không thì đặt làm thuộc tính
							} khác {
								this.attr (trận đấu, ngữ cảnh [trận đấu]);
							}
						}
					}

					trả lại cái này;

				// XỬ LÝ: $ (# id)
				} khác {
					elem = document.getElementById (match [2]);

					if (elem) {

						// Chèn phần tử trực tiếp vào đối tượng jQuery
						this [0] = elem;
						this.length = 1;
					}
					trả lại cái này;
				}

			// XỬ LÝ: $ (expr, $ (...))
			} else if (! context || context.jquery) {
				return (ngữ cảnh || gốc) .find (bộ chọn);

			// XỬ LÝ: $ (expr, context)
			// (tương đương với: $ (context) .find (expr)
			} khác {
				trả về this.constructor (ngữ cảnh) .find (bộ chọn);
			}

		// XỬ LÝ: $ (DOMElement)
		} else if (selector.nodeType) {
			this [0] = bộ chọn;
			this.length = 1;
			trả lại cái này;

		// XỬ LÝ: $ (hàm)
		// Lối tắt cho tài liệu đã sẵn sàng
		} else if (isFunction (selector)) {
			trả về root.ready! == undefined?
				root.ready (bộ chọn):

				// Thực thi ngay lập tức nếu không có sẵn sàng
				bộ chọn (jQuery);
		}

		return jQuery.makeArray (bộ chọn, cái này);
	};

// Cung cấp cho hàm init nguyên mẫu jQuery để tạo sau này
init.prototype = jQuery.fn;

// Khởi tạo tham chiếu trung tâm
rootjQuery = jQuery (tài liệu);


var rparentsprev = / ^ (?: cha mẹ | trước (?: Cho đến khi | Tất cả)) /,

	// Các phương thức được đảm bảo tạo ra một tập hợp duy nhất khi bắt đầu từ một tập hợp duy nhất
	Đảm bảoUnique = {
		trẻ em: đúng,
		nội dung: đúng,
		tiếp theo: đúng,
		trước: đúng
	};

jQuery.fn.extend ({
	has: function (target) {
		var target = jQuery (target, this),
			l = target.length;

		trả về this.filter (function () {
			var i = 0;
			cho (; i <l; i ++) {
				if (jQuery.contains (this, target [i])) {
					trả về true;
				}
			}
		});
	},

	gần nhất: chức năng (bộ chọn, ngữ cảnh) {
		var cur,
			i = 0,
			l = this.length,
			phù hợp = [],
			target = typeof selectors! == "string" && jQuery (selectors);

		// Các bộ chọn vị trí không bao giờ khớp, vì không có ngữ cảnh _selection_
		if (! rneedsContext.test (selectors)) {
			cho (; i <l; i ++) {
				for (cur = this [i]; cur && cur! == context; cur = cur.parentNode) {

					// Luôn bỏ qua các đoạn tài liệu
					if (cur.nodeType <11 && (target?
						target.index (cur)> -1:

						// Không chuyển các phần tử không phải là phần tử cho Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector (cur, bộ chọn))) {

						phù hợp.push (cur);
						phá vỡ;
					}
				}
			}
		}

		return this.pushStack (match.length> 1? jQuery.uniqueSort (match): match);
	},

	// Xác định vị trí của một phần tử trong tập hợp
	index: function (elem) {

		// Không có đối số, trả về chỉ mục trong cha
		nếu (! elem) {
			trả về (cái này [0] && cái này [0] .parentNode)? this.first (). prevAll (). length: -1;
		}

		// Lập chỉ mục trong bộ chọn
		if (typeof elem === "string") {
			return indexOf.call (jQuery (elem), this [0]);
		}

		// Định vị vị trí của phần tử mong muốn
		trả về indexOf.call (cái này,

			// Nếu nó nhận một đối tượng jQuery, thì phần tử đầu tiên sẽ được sử dụng
			elem.jquery? elem [0]: elem
		);
	},

	add: function (selector, context) {
		return this.pushStack (
			jQuery.uniqueSort (
				jQuery.merge (this.get (), jQuery (bộ chọn, ngữ cảnh))
			)
		);
	},

	addBack: function (selector) {
		trả về this.add (selector == null?
			this.prevObject: this.prevObject.filter (bộ chọn)
		);
	}
});

anh chị em hàm (cur, dir) {
	while ((cur = cur [dir]) && cur.nodeType! == 1) {}
	trả lại cur;
}

jQuery.each ({
	cha mẹ: function (elem) {
		var parent = elem.parentNode;
		trả về cha && parent.nodeType! == 11? cha mẹ: null;
	},
	cha mẹ: function (elem) {
		return dir (elem, "parentNode");
	},
	cha mẹUntil: function (elem, _i, cho đến khi) {
		return dir (elem, "parentNode", cho đến khi);
	},
	tiếp theo: function (elem) {
		return anh chị em (elem, "nextSibling");
	},
	trước: hàm (elem) {
		return anh chị em (elem, "beforeSibling");
	},
	nextAll: function (elem) {
		return dir (elem, "nextSibling");
	},
	trước đây: function (elem) {
		return dir (elem, "beforeSibling");
	},
	nextUntil: function (elem, _i, cho đến khi) {
		return dir (elem, "nextSibling", cho đến khi);
	},
	trước khi cho đến: hàm (elem, _i, cho đến khi) {
		return dir (elem, "beforeSibling", cho đến khi);
	},
	anh chị em: function (elem) {
		return anh chị em ((elem.parentNode || {}) .firstChild, elem);
	},
	con: function (elem) {
		trả lại anh chị em (elem.firstChild);
	},
	nội dung: function (elem) {
		if (elem.contentDocument! = null &&

			// Hỗ trợ: IE 11+
			// Các phần tử <object> không có thuộc tính `data` có một đối tượng
			// `contentDocument` với nguyên mẫu` null`.
			getProto (elem.contentDocument)) {

			trả về elem.contentDocument;
		}

		// Hỗ trợ: chỉ IE 9-11, chỉ iOS 7, chỉ Trình duyệt Android <= 4.3
		// Coi phần tử mẫu như một phần tử thông thường trong các trình duyệt
		// không hỗ trợ nó.
		if (nodeName (elem, "template")) {
			elem = elem.content || độ cao;
		}

		return jQuery.merge ([], elem.childNodes);
	}
}, function (name, fn) {
	jQuery.fn [name] = function (cho đến khi, bộ chọn) {
		var match = jQuery.map (this, fn, Until);

		if (name.slice (-5)! == "Until") {
			bộ chọn = cho đến khi;
		}

		if (selector && typeof selector === "string") {
			match = jQuery.filter (bộ chọn, đối sánh);
		}

		if (this.length> 1) {

			// Loại bỏ các bản sao
			if (! ensureUnique [name]) {
				jQuery.uniqueSort (đối sánh);
			}

			// Đảo ngược thứ tự dành cho cha mẹ * và các dẫn xuất trước đó
			if (rparentsprev.test (name)) {
				match.reverse ();
			}
		}

		return this.pushStack (đã khớp);
	};
});
var rnothtmlwhite = (/ [^ \ x20 \ t \ r \ n \ f] + / g);



// Chuyển đổi các tùy chọn có định dạng chuỗi thành các tùy chọn có định dạng Đối tượng
function createOptions (tùy chọn) {
	đối tượng var = {};
	jQuery.each (options.match (rnothtmlwhite) || [], function (_, flag) {
		object [flag] = true;
	});
	đối tượng trả lại;
}

/ *
 * Tạo danh sách gọi lại bằng các tham số sau:
 *
 * tùy chọn: danh sách tùy chọn các tùy chọn được phân tách bằng dấu cách sẽ thay đổi cách
 * danh sách gọi lại hoạt động hoặc một đối tượng tùy chọn truyền thống hơn
 *
 * Theo mặc định, danh sách gọi lại sẽ hoạt động giống như danh sách gọi lại sự kiện và có thể
 * "bắn" nhiều lần.
 *
 * Các tùy chọn có thể có:
 *
 * một lần: sẽ đảm bảo danh sách gọi lại chỉ có thể được kích hoạt một lần (như Hoãn)
 *
 * memory: sẽ theo dõi các giá trị trước đó và sẽ gọi bất kỳ lệnh gọi lại nào được thêm vào
 * sau khi danh sách bị sa thải ngay lập tức với "thuộc lòng" mới nhất
 * giá trị (chẳng hạn như Bị hoãn lại)
 *
 * duy nhất: sẽ đảm bảo chỉ có thể thêm lệnh gọi lại một lần (không có bản sao trong danh sách)
 *
 * stopOnFalse: ngắt cuộc gọi khi một cuộc gọi lại trả về false
 *
 * /
jQuery.Callbacks = function (tùy chọn) {

	// Chuyển đổi các tùy chọn từ định dạng chuỗi sang định dạng đối tượng nếu cần
	// (chúng tôi kiểm tra bộ nhớ cache trước)
	tùy chọn = tùy chọn typeof === "chuỗi"?
		createOptions (tùy chọn):
		jQuery.extend ({}, tùy chọn);

	var // Gắn cờ để biết danh sách hiện đang kích hoạt hay không
		bắn,

		// Giá trị kích hoạt cuối cùng cho danh sách không thể quên
		ký ức,

		// Gắn cờ để biết danh sách đã được kích hoạt chưa
		Bị sa thải,

		// Gắn cờ để ngăn kích hoạt
		bị khóa,

		// Danh sách gọi lại thực tế
		danh sách = [],

		// Hàng đợi dữ liệu thực thi cho danh sách có thể lặp lại
		hàng đợi = [],

		// Chỉ mục của lệnh gọi lại hiện đang kích hoạt (được sửa đổi bằng cách thêm / xóa nếu cần)
		shootingIndex = -1,

		// Kích hoạt lệnh gọi lại
		fire = function () {

			// Thực thi một lần kích hoạt
			bị khóa = bị khóa || tùy chọn.once;

			// Thực thi lệnh gọi lại cho tất cả các lần thực thi đang chờ xử lý,
			// tôn trọng các ghi đè fireIndex và các thay đổi về thời gian chạy
			sa thải = sa thải = true;
			for (; queue.length; fireIndex = -1) {
				memory = queue.shift ();
				while (++ shootingIndex <list.length) {

					// Chạy lệnh gọi lại và kiểm tra kết thúc sớm
					if (list [shootingIndex] .apply (memory [0], memory [1]) === false &&
						options.stopOnFalse) {

						// Nhảy đến kết thúc và quên dữ liệu để .add không kích hoạt lại
						fireIndex = list.length;
						bộ nhớ = false;
					}
				}
			}

			// Quên dữ liệu nếu chúng ta đã làm xong
			if (! options.memory) {
				bộ nhớ = false;
			}

			sa thải = false;

			// Dọn dẹp nếu chúng ta bắn xong
			nếu (bị khóa) {

				// Giữ một danh sách trống nếu chúng ta có dữ liệu cho các cuộc gọi thêm trong tương lai
				nếu (bộ nhớ) {
					danh sách = [];

				// Nếu không, đối tượng này được sử dụng
				} khác {
					danh sách = "";
				}
			}
		},

		// Đối tượng gọi lại thực tế
		bản thân = {

			// Thêm một lệnh gọi lại hoặc một tập hợp các lệnh gọi lại vào danh sách
			thêm: function () {
				if (danh sách) {

					// Nếu chúng ta có bộ nhớ từ một lần chạy trước, chúng ta nên kích hoạt sau khi thêm
					if (bộ nhớ &&! kích hoạt) {
						fireIndex = list.length - 1;
						queue.push (bộ nhớ);
					}

					(function add (args) {
						jQuery.each (args, function (_, arg) {
							if (isFunction (arg)) {
								if (! options.unique ||! self.has (arg)) {
									list.push (arg);
								}
							} else if (arg && arg.length && toType (arg)! == "string") {

								// Kiểm tra đệ quy
								thêm (arg);
							}
						});
					} )( tranh luận );

					if (bộ nhớ &&! kích hoạt) {
						lửa();
					}
				}
				trả lại cái này;
			},

			// Xóa một cuộc gọi lại khỏi danh sách
			loại bỏ: function () {
				jQuery.each (đối số, hàm (_, arg) {
					chỉ số var;
					while ((index = jQuery.inArray (arg, list, index))> -1) {
						list.splice (chỉ mục, 1);

						// Xử lý các chỉ mục kích hoạt
						if (index <= shootingIndex) {
							shootingIndex--;
						}
					}
				});
				trả lại cái này;
			},

			// Kiểm tra xem một lệnh gọi lại đã cho có trong danh sách hay không.
			// Nếu không có đối số nào được đưa ra, hãy trả về danh sách có đính kèm lệnh gọi lại hay không.
			has: function (fn) {
				trả lại fn?
					jQuery.inArray (fn, list)> -1:
					list.length> 0;
			},

			// Xóa tất cả các lệnh gọi lại khỏi danh sách
			rỗng: function () {
				if (danh sách) {
					danh sách = [];
				}
				trả lại cái này;
			},

			// Tắt .fire và .add
			// Hủy bỏ mọi thực thi hiện tại / đang chờ xử lý
			// Xóa tất cả các lệnh gọi lại và giá trị
			vô hiệu hóa: function () {
				bị khóa = hàng đợi = [];
				list = memory = "";
				trả lại cái này;
			},
			bị vô hiệu hóa: function () {
				danh sách trở lại;
			},

			// Tắt .fire
			// Đồng thời vô hiệu hóa .add trừ khi chúng ta có bộ nhớ (vì nó sẽ không có tác dụng)
			// Huỷ bỏ mọi thực thi đang chờ xử lý
			lock: function () {
				bị khóa = hàng đợi = [];
				if (! memory &&! kích hoạt) {
					list = memory = "";
				}
				trả lại cái này;
			},
			bị khóa: function () {
				trở lại !! bị khóa;
			},

			// Gọi tất cả các lệnh gọi lại với ngữ cảnh và đối số đã cho
			fireWith: function (context, args) {
				if (! lock) {
					args = args || [];
					args = [bối cảnh, args.slice? args.slice (): args];
					queue.push (args);
					if (! kích hoạt) {
						lửa();
					}
				}
				trả lại cái này;
			},

			// Gọi tất cả các lệnh gọi lại với các đối số đã cho
			fire: function () {
				self.fireWith (this, các đối số);
				trả lại cái này;
			},

			// Để biết liệu các lệnh gọi lại đã được gọi ít nhất một lần hay chưa
			đã kích hoạt: function () {
				trở lại !! sa thải;
			}
		};

	trở lại bản thân;
};


function Identity (v) {
	trả lại v;
}
function Thrower (ví dụ) {
	ném người yêu cũ;
}

function acceptValue (giá trị, giải quyết, từ chối, noValue) {
	phương pháp var;

	thử {

		// Kiểm tra khía cạnh hứa hẹn trước để đặc quyền hành vi đồng bộ
		if (value && isFunction ((method = value.promise))) {
			method.call (value) .done (giải quyết) .fail (từ chối);

		// Các quyền khác
		} else if (value && isFunction ((method = value.then))) {
			method.call (giá trị, giải quyết, từ chối);

		// Khác không thuộc quyền sở hữu
		} khác {

			// Kiểm soát các đối số `giải quyết` bằng cách cho phép Array # lát ép kiểu boolean` noValue` thành số nguyên:
			// * false: [giá trị] .slice (0) => giải quyết (giá trị)
			// * true: [giá trị] .slice (1) => giải quyết ()
			giải quyết.apply (không xác định, [giá trị] .slice (noValue));
		}

	// Đối với Promises / A +, chuyển đổi ngoại lệ thành từ chối
	// Vì jQuery.w khi không mở các quyền, chúng ta có thể bỏ qua các bước kiểm tra bổ sung xuất hiện trong
	// Deferred # sau đó để loại bỏ từ chối có điều kiện.
	} catch (value) {

		// Hỗ trợ: chỉ dành cho Android 4.0
		// Các hàm chế độ nghiêm ngặt được gọi mà không có .call / .apply lấy ngữ cảnh đối tượng toàn cục
		từ chối.apply (không xác định, [giá trị]);
	}
}

jQuery.extend ({

	Đã hoãn lại: function (func) {
		var tuples = [

				// hành động, thêm trình nghe, gọi lại,
				// ... .thì trình xử lý, chỉ mục đối số, [trạng thái cuối cùng]
				["thông báo", "tiến trình", jQuery.Callbacks ("bộ nhớ"),
					jQuery.Callbacks ("bộ nhớ"), 2],
				["giải quyết", "xong", jQuery.Callbacks ("bộ nhớ một lần"),
					jQuery.Callbacks ("bộ nhớ một lần"), 0, "đã giải quyết"],
				["từ chối", "thất bại", jQuery.Callbacks ("bộ nhớ một lần"),
					jQuery.Callbacks ("bộ nhớ một lần"), 1, "bị từ chối"]
			],
			state = "đang chờ xử lý",
			hứa = {
				chức vụ Tiểu bang() {
					trở lại trạng thái;
				},
				luôn luôn: function () {
					deferred.done (đối số) .fail (đối số);
					trả lại cái này;
				},
				"catch": function (fn) {
					return Promise.then (null, fn);
				},

				// Giữ đường dẫn cho back-compat
				pipe: function (/ * fnDone, fnFail, fnProgress * /) {
					var fns = đối số;

					return jQuery.Deferred (function (newDefer) {
						jQuery.each (tuples, function (_i, tuple) {

							// Ánh xạ các bộ giá trị (tiến trình, hoàn thành, không thành công) với các đối số (hoàn thành, không thành công, tiến trình)
							var fn = isFunction (fns [tuple [4]]) && fns [tuple [4]];

							// deferred.progress (function () {bind to newDefer hoặc newDefer.notify})
							// deferred.done (function () {bind to newDefer hoặc newDefer.resolve})
							// deferred.fail (function () {bind to newDefer hoặc newDefer.reject})
							hoãn lại [tuple [1]] (function () {
								var return = fn && fn.apply (this, các đối số);
								if (return && isFunction (return.promise)) {
									return.promise ()
										.progress (newDefer.notify)
										.done (newDefer.resolve)
										.fail (newDefer.reject);
								} khác {
									newDefer [tuple [0] + "With"] (
										cái này,
										fn? [return]: đối số
									);
								}
							});
						});
						fns = null;
					} ).lời hứa();
				},
				then: function (onFulfilled, onRejected, onProgress) {
					var maxDepth = 0;
					hàm giải quyết (độ sâu, trì hoãn, trình xử lý, đặc biệt) {
						hàm trả về () {
							var that = this,
								args = đối số,
								mayThrow = function () {
									var được trả về, sau đó;

									// Hỗ trợ: Promises / A + phần 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Bỏ qua các lần phân giải kép
									nếu (độ sâu <maxDepth) {
										trở về;
									}

									return = handler.apply (that, args);

									// Hỗ trợ: Promises / A + phần 2.3.1
									// https://promisesaplus.com/#point-48
									if (trả về === deferred.promise ()) {
										ném TypeError mới ("Có thể tự phân giải");
									}

									// Hỗ trợ: Promises / A + phần 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Truy xuất `then` chỉ một lần
									then = trả lại &&

										// Hỗ trợ: Promises / A + phần 2.3.4
										// https://promisesaplus.com/#point-64
										// Chỉ kiểm tra các đối tượng và chức năng xem có khả năng không
										(typeof trả về === "đối tượng" ||
											typeof trả về === "function") &&
										đã trả lại. sau đó;

									// Xử lý anable trả về
									if (isFunction (then)) {

										// Bộ xử lý đặc biệt (thông báo) chỉ chờ giải quyết
										nếu (đặc biệt) {
											sau đó gọi(
												trả lại,
												giải quyết (maxDepth, hoãn lại, Identity, đặc biệt),
												giải quyết (maxDepth, hoãn lại, Thrower, đặc biệt)
											);

										// Các bộ xử lý bình thường (giải quyết) cũng đang tiến triển
										} khác {

											// ... và bỏ qua các giá trị độ phân giải cũ hơn
											maxDepth ++;

											sau đó gọi(
												trả lại,
												giải quyết (maxDepth, hoãn lại, Identity, đặc biệt),
												giải quyết (maxDepth, hoãn lại, Thrower, đặc biệt),
												giải quyết (maxDepth, hoãn lại, Identity,
													deferred.notifyWith)
											);
										}

									// Xử lý tất cả các giá trị trả về khác
									} khác {

										// Chỉ những trình xử lý thay thế mới chuyển qua ngữ cảnh
										// và nhiều giá trị (hành vi không phải đặc tả)
										if (trình xử lý! == Identity) {
											that = không xác định;
											args = [trả về];
										}

										// Xử lý (các) giá trị
										// Quá trình mặc định được giải quyết
										(special || deferred.resolveWith) (that, args);
									}
								},

								// Chỉ các bộ xử lý bình thường (giải quyết) mới bắt và từ chối các ngoại lệ
								quy trình = đặc biệt?
									mayThrow:
									hàm số() {
										thử {
											maythrow ();
										} bắt (e) {

											if (jQuery.Deferred.exceptionHook) {
												jQuery.Deferred.exceptionHook (e,
													process.stackTrace);
											}

											// Hỗ trợ: Promises / A + phần 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Bỏ qua các ngoại lệ sau giải quyết
											if (depth + 1> = maxDepth) {

												// Chỉ những trình xử lý thay thế mới chuyển qua ngữ cảnh
												// và nhiều giá trị (hành vi không phải đặc tả)
												if (trình xử lý! == người ném) {
													that = không xác định;
													args = [e];
												}

												deferred.rejectWith (that, args);
											}
										}
									};

							// Hỗ trợ: Promises / A + phần 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Giải quyết lại lời hứa ngay lập tức để tránh bị từ chối sai
							// lỗi tiếp theo
							nếu (độ sâu) {
								tiến trình();
							} khác {

								// Gọi một hook tùy chọn để ghi lại ngăn xếp, trong trường hợp ngoại lệ
								// vì nó bị mất khi thực thi không đồng bộ
								if (jQuery.Deferred.getStackHook) {
									process.stackTrace = jQuery.Deferred.getStackHook ();
								}
								window.setTimeout (tiến trình);
							}
						};
					}

					return jQuery.Deferred (function (newDefer) {

						// process_handlers.add (...)
						bộ giá trị [0] [3] .add (
							giải quyết(
								0,
								newDefer,
								isFunction (onProgress)?
									onProgress:
									Xác thực,
								newDefer.notifyWith
							)
						);

						// Full_handlers.add (...)
						bộ giá trị [1] [3] .add (
							giải quyết(
								0,
								newDefer,
								isFunction (onFulfilled)?
									onFulfilled:
									Xác thực
							)
						);

						// từ chối_handlers.add (...)
						bộ giá trị [2] [3] .add (
							giải quyết(
								0,
								newDefer,
								isFunction (onRejected)?
									onRejected:
									Người giao cầu
							)
						);
					} ).lời hứa();
				},

				// Nhận một lời hứa cho việc trì hoãn này
				// Nếu obj được cung cấp, khía cạnh hứa sẽ được thêm vào đối tượng
				Hứa hẹn: function (obj) {
					trả về obj! = null? jQuery.extend (obj, promise): lời hứa;
				}
			},
			hoãn lại = {};

		// Thêm các phương thức dành riêng cho danh sách
		jQuery.each (tuples, function (i, tuple) {
			var list = tuple [2],
				stateString = tuple [5];

			// promise.progress = list.add
			// promise.done = list.add
			// Hứa hẹn.fail = list.add
			Hứa [tuple [1]] = list.add;

			// Xử lý trạng thái
			if (stateString) {
				list.add (
					hàm số() {

						// trạng thái = "giải quyết" (tức là đã hoàn thành)
						// trạng thái = "bị từ chối"
						trạng thái = stateString;
					},

					// từ chối_callbacks.disable
					// Full_callbacks.disable
					bộ giá trị [3 - i] [2]. vô hiệu hóa,

					// từ chối_handlers.disable
					// Full_handlers.disable
					bộ giá trị [3 - i] [3]. vô hiệu hóa,

					// process_callbacks.lock
					bộ giá trị [0] [2]. khóa,

					// process_handlers.lock
					bộ giá trị [0] [3]. khóa
				);
			}

			// process_handlers.fire
			// Full_handlers.fire
			// từ chối_handlers.fire
			list.add (tuple [3] .fire);

			// deferred.notify = function () {deferred.notifyWith (...)}
			// deferred.resolve = function () {deferred.resolveWith (...)}
			// deferred.reject = function () {deferred.rejectWith (...)}
			deferred [tuple [0]] = function () {
				deferred [tuple [0] + "With"] (this === deferred? undefined: this, các đối số);
				trả lại cái này;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred [tuple [0] + "With"] = list.fireWith;
		});

		// Thực hiện lời hứa hoãn lại
		hứa hẹn.promise (hoãn lại);

		// Gọi func đã cho nếu có
		if (func) {
			func.call (hoãn lại, hoãn lại);
		}

		// Tất cả đã được làm xong!
		trả lại hàng trả chậm;
	},

	// Người trợ giúp trì hoãn
	when: function (singleValue) {
		var

			// số lượng cấp dưới chưa hoàn thành
			còn lại = đối số.length,

			// số lượng các đối số chưa được xử lý
			i = còn lại,

			// dữ liệu thực hiện cấp dưới
			ResolutionContexts = Array (i),
			Giải quyếtValues ​​= Slice.call (đối số),

			// cái chủ bị hoãn lại
			master = jQuery.Deferred (),

			// nhà máy gọi lại cấp dưới
			updateFunc = function (i) {
				hàm trả về (giá trị) {
					ResolutionContexts [i] = this;
					Giải quyếtValues ​​[i] = Đối số.length> 1? slice.call (các đối số): giá trị;
					if (! (- còn lại)) {
						master.resolveWith (ResolutionContexts, ResolutionValues);
					}
				};
			};

		// Các đối số đơn và rỗng được sử dụng như Promise.resolve
		if (còn lại <= 1) {
			acceptValue (singleValue, master.done (updateFunc (i)) .resolve, master.reject,
				! còn lại);

			// Sử dụng .then () để mở các phần mềm phụ (xem gh-3000)
			if (master.state () === "đang chờ xử lý" ||
				isFunction (Giải quyết vấn đề [i] && Giải quyết vấn đề [i] .then)) {

				return master.then ();
			}
		}

		// Nhiều đối số được tổng hợp giống như các phần tử mảng Promise.all
		trong khi tôi-- ) {
			acceptValue (ResolutionValues ​​[i], updateFunc (i), master.reject);
		}

		trả về master.promise ();
	}
});


// Những điều này thường chỉ ra lỗi của lập trình viên trong quá trình phát triển,
// cảnh báo về chúng càng sớm càng tốt thay vì nuốt chúng theo mặc định.
var rerrorNames = / ^ (Eval | Internal | Phạm vi | Tham chiếu | Cú pháp | Loại | URI) Lỗi $ /;

jQuery.Deferred.exceptionHook = function (error, stack) {

	// Hỗ trợ: chỉ IE 8-9
	// Bảng điều khiển tồn tại khi các công cụ dành cho nhà phát triển đang mở, điều này có thể xảy ra bất kỳ lúc nào
	if (window.console && window.console.warn && error && rerrorNames.test (error.name)) {
		window.console.warn ("jQuery.Deferred exception:" + error.message, error.stack, stack);
	}
};




jQuery.readyException = function (error) {
	window.setTimeout (function () {
		lỗi ném;
	});
};




// Đã hoãn sử dụng trên DOM đã sẵn sàng
var readyList = jQuery.Deferred ();

jQuery.fn.ready = function (fn) {

	readyList
		.then (fn)

		// Wrap jQuery.readyException trong một hàm để tra cứu
		// xảy ra tại thời điểm xử lý lỗi thay vì gọi lại
		// sự đăng ký.
		.catch (function (error) {
			jQuery.readyException (lỗi);
		});

	trả lại cái này;
};

jQuery.extend ({

	// DOM đã sẵn sàng để sử dụng chưa? Đặt thành true khi nó xảy ra.
	isReady: false,

	// Một bộ đếm để theo dõi có bao nhiêu mục cần đợi trước đó
	// sự kiện sẵn sàng kích hoạt. Xem # 6781
	readyWait: 1,

	// Xử lý khi DOM đã sẵn sàng
	sẵn sàng: function (đợi) {

		// Huỷ bỏ nếu có khoản lưu giữ đang chờ xử lý hoặc chúng tôi đã sẵn sàng
		if (wait === true? --jQuery.readyWait: jQuery.isReady) {
			trở về;
		}

		// Hãy nhớ rằng DOM đã sẵn sàng
		jQuery.isReady = true;

		// Nếu một sự kiện DOM Ready bình thường được kích hoạt, hãy giảm và đợi nếu cần
		if (đợi đã! == true && --jQuery.readyWait> 0) {
			trở về;
		}

		// Nếu có các hàm bị ràng buộc, để thực thi
		readyList.resolveWith (document, [jQuery]);
	}
});

jQuery.ready.then = readyList.then;

// Phương thức xử lý sự kiện sẵn sàng và phương thức tự dọn dẹp
chức năng đã hoàn thành () {
	document.removeEventListener ("DOMContentLoaded", đã hoàn thành);
	window.removeEventListener ("tải", đã hoàn thành);
	jQuery.ready ();
}

// Bắt các trường hợp $ (document) .ready () được gọi
// sau khi sự kiện trình duyệt đã xảy ra.
// Chỉ hỗ trợ: IE <= 9 - 10
// IE cũ hơn đôi khi báo hiệu "tương tác" quá sớm
if (document.readyState === "hoàn thành" ||
	(document.readyState! == "loading" &&! document.documentElement.doScroll)) {

	// Xử lý nó không đồng bộ để cho phép các tập lệnh có cơ hội trì hoãn sẵn sàng
	window.setTimeout (jQuery.ready);

} khác {

	// Sử dụng lệnh gọi lại sự kiện tiện dụng
	document.addEventListener ("DOMContentLoaded", đã hoàn thành);

	// Dự phòng cho window.onload, sẽ luôn hoạt động
	window.addEventListener ("tải", đã hoàn thành);
}




// Phương thức đa chức năng để lấy và đặt giá trị của một tập hợp
// Giá trị / s có thể được thực thi tùy chọn nếu đó là một hàm
var access = function (elems, fn, key, value, chainable, blankGet, raw) {
	var i = 0,
		len = elems.length,
		số lượng lớn = key == null;

	// Đặt nhiều giá trị
	if (toType (key) === "object") {
		chainable = true;
		cho (tôi trong khóa) {
			access (elems, fn, i, key [i], true, blankGet, raw);
		}

	// Đặt một giá trị
	} else if (value! == undefined) {
		chainable = true;

		if (! isFunction (value)) {
			nguyên = true;
		}

		nếu (số lượng lớn) {

			// Các hoạt động hàng loạt chạy đối với toàn bộ tập hợp
			nếu (thô) {
				fn.call (elems, value);
				fn = null;

			// ... ngoại trừ khi thực thi các giá trị hàm
			} khác {
				số lượng lớn = fn;
				fn = function (elem, _key, value) {
					trả về số lượng lớn.call (jQuery (elem), giá trị);
				};
			}
		}

		nếu (fn) {
			for (; i <len; i ++) {
				fn (
					elems [i], key, raw?
					giá trị :
					value.call (elems [i], i, fn (elems [i], key))
				);
			}
		}
	}

	nếu (có thể) {
		trả về số điện thoại;
	}

	// Được
	nếu (số lượng lớn) {
		return fn.call (elems);
	}

	quay trở lại len? fn (elems [0], key): blankGet;
};


// Khớp chuỗi đứt nét để tạo lạc đà
var rmsPrefix = / ^ - ms- /,
	rdashAlpha = / - ([az]) / g;

// Được sử dụng bởi camelCase làm lệnh gọi lại để thay thế ()
function fcamelCase (_all, letter) {
	return letter.toUpperCase ();
}

// Chuyển đổi dấu gạch ngang thành camelCase; được sử dụng bởi các mô-đun css và dữ liệu
// Hỗ trợ: IE <= 9 - 11, Edge 12 - 15
// Microsoft quên lấy tiền tố nhà cung cấp của họ (# 9572)
function camelCase (string) {
	return string.replace (rmsPrefix, "ms-") .replace (rdashAlpha, fcamelCase);
}
var acceptData = function (owner) {

	// Chỉ chấp nhận:
	// - Nút
	// - Node.ELEMENT_NODE
	// - Node.DOCUMENT_NODE
	// - Vật
	// - Không tí nào
	return owner.nodeType === 1 || owner.nodeType === 9 || ! (+ owner.nodeType);
};




function Data () {
	this.expando = jQuery.expando + Data.uid ++;
}

Data.uid = 1;

Data.prototype = {

	cache: function (chủ sở hữu) {

		// Kiểm tra xem đối tượng chủ sở hữu đã có bộ nhớ đệm chưa
		var value = owner [this.expando];

		// Nếu không, hãy tạo một
		if (! value) {
			value = Object.create (null);

			// Chúng tôi có thể chấp nhận dữ liệu cho các nút không phải phần tử trong các trình duyệt hiện đại,
			// nhưng chúng ta không nên, hãy xem # 8335.
			// Luôn trả về một đối tượng rỗng.
			if (acceptData (chủ sở hữu)) {

				// Nếu nó là một nút không có khả năng được stringify-ed hoặc lặp lại
				// sử dụng phép gán đơn giản
				if (owner.nodeType) {
					chủ sở hữu [this.expando] = giá trị;

				// Nếu không, hãy bảo mật nó trong một thuộc tính không liệt kê được
				// có thể định cấu hình phải đúng để cho phép thuộc tính
				// bị xóa khi dữ liệu bị xóa
				} khác {
					Object.defineProperty (chủ sở hữu, this.expando, {
						value: giá trị,
						có thể cấu hình: true
					});
				}
			}
		}

		giá trị trả về;
	},
	set: function (chủ sở hữu, dữ liệu, giá trị) {
		var prop,
			cache = this.cache (chủ sở hữu);

		// Xử lý: [owner, key, value] args
		// Luôn sử dụng khóa camelCase (gh-2257)
		if (typeof data === "string") {
			cache [camelCase (data)] = value;

		// Xử lý: [owner, {property}] args
		} khác {

			// Sao chép từng thuộc tính vào đối tượng bộ đệm
			cho (hỗ trợ dữ liệu) {
				cache [camelCase (prop)] = data [prop];
			}
		}
		trả lại bộ nhớ cache;
	},
	get: function (chủ sở hữu, khóa) {
		khóa trả về === không xác định?
			this.cache (chủ sở hữu):

			// Luôn sử dụng khóa camelCase (gh-2257)
			chủ sở hữu [this.expando] && chủ sở hữu [this.expando] [camelCase (khóa)];
	},
	access: function (chủ sở hữu, khóa, giá trị) {

		// Trong các trường hợp:
		//
		// 1. Không có khóa nào được chỉ định
		// 2. Một khóa chuỗi đã được chỉ định, nhưng không có giá trị nào được cung cấp
		//
		// Đi theo đường dẫn "read" và cho phép phương thức get xác định
		// giá trị nào sẽ trả về, tương ứng:
		//
		// 1. Toàn bộ đối tượng cache
		// 2. Dữ liệu được lưu trữ tại khóa
		//
		if (key === undefined ||
				((key && typeof key === "string") && value === undefined)) {

			return this.get (chủ sở hữu, khóa);
		}

		// Khi khóa không phải là một chuỗi hoặc cả khóa và giá trị
		// được chỉ định, đặt hoặc mở rộng (các đối tượng hiện có) với:
		//
		// 1. Một đối tượng của thuộc tính
		// 2. Một khóa và giá trị
		//
		this.set (chủ sở hữu, khóa, giá trị);

		// Vì đường dẫn "set" có thể có hai điểm vào
		// trả về dữ liệu mong đợi dựa trên đường dẫn nào đã được lấy [*]
		trả về giá trị! == không xác định? giá trị: key;
	},
	remove: function (chủ sở hữu, khóa) {
		var i,
			cache = chủ sở hữu [this.expando];

		if (cache === undefined) {
			trở về;
		}

		if (key! == undefined) {

			// Hỗ trợ chuỗi khóa được phân tách bằng mảng hoặc dấu cách
			if (Array.isArray (key)) {

				// Nếu khóa là một mảng các khóa ...
				// Chúng tôi luôn đặt các khóa camelCase, vì vậy hãy xóa khóa đó.
				key = key.map (camelCase);
			} khác {
				key = camelCase (chìa khóa);

				// Nếu một khóa có khoảng trắng tồn tại, hãy sử dụng nó.
				// Nếu không, hãy tạo một mảng bằng cách khớp với khoảng trắng không phải
				key = key trong cache?
					[ Chìa khóa ] :
					(key.match (rnothtmlwhite) || []);
			}

			i = key.length;

			trong khi tôi-- ) {
				xóa bộ nhớ đệm [key [i]];
			}
		}

		// Xóa phần mở rộng nếu không còn dữ liệu
		if (key === undefined || jQuery.isEmptyObject (cache)) {

			// Hỗ trợ: Chrome <= 35 - 45
			// Hiệu suất Webkit & Blink bị ảnh hưởng khi xóa thuộc tính
			// từ các nút DOM, vì vậy hãy đặt thành không xác định thay thế
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bị hạn chế lỗi)
			if (owner.nodeType) {
				owner [this.expando] = undefined;
			} khác {
				xóa chủ sở hữu [this.expando];
			}
		}
	},
	hasData: function (chủ sở hữu) {
		var cache = owner [this.expando];
		return cache! == undefined &&! jQuery.isEmptyObject (cache);
	}
};
var dataPriv = new Data ();

var dataUser = new Data ();



// Tóm tắt triển khai
//
// 1. Thực thi khả năng tương thích ngữ nghĩa và bề mặt API với nhánh 1.9.x
// 2. Cải thiện khả năng bảo trì của mô-đun bằng cách giảm dung lượng lưu trữ
// đường dẫn đến một cơ chế duy nhất.
// 3. Sử dụng cùng một cơ chế duy nhất để hỗ trợ dữ liệu "riêng tư" và "người dùng".
// 4. _Không bao giờ để lộ dữ liệu "riêng tư" với mã người dùng (VIỆC CẦN LÀM: Drop _data, _removeData)
// 5. Tránh để lộ chi tiết triển khai trên các đối tượng người dùng (ví dụ: thuộc tính expando)
// 6. Cung cấp một đường dẫn rõ ràng để triển khai nâng cấp lên WeakMap vào năm 2014

var rbrace = / ^ (?: \ {[\ w \ W] * \} | \ [[\ w \ W] * \]) $ /,
	rmultiDash = / [AZ] / g;

function getData (data) {
	if (data === "true") {
		trả về true;
	}

	if (data === "false") {
		trả về sai;
	}

	if (data === "null") {
		trả về null;
	}

	// Chỉ chuyển đổi thành một số nếu nó không thay đổi chuỗi
	if (data === + data + "") {
		trả về + dữ liệu;
	}

	if (rbrace.test (data)) {
		trả về JSON.parse (dữ liệu);
	}

	trả về dữ liệu;
}

function dataAttr (elem, key, data) {
	tên var;

	// Nếu không tìm thấy gì trong nội bộ, hãy thử tìm nạp bất kỳ
	// dữ liệu từ thuộc tính data- * HTML5
	if (data === undefined && elem.nodeType === 1) {
		name = "data-" + key.replace (rmultiDash, "- $ &") .toLowerCase ();
		data = elem.getAttribute (tên);

		if (typeof data === "string") {
			thử {
				data = getData (dữ liệu);
			} bắt (e) {}

			// Đảm bảo rằng chúng tôi đã thiết lập dữ liệu để nó không bị thay đổi sau này
			dataUser.set (elem, khóa, dữ liệu);
		} khác {
			dữ liệu = không xác định;
		}
	}
	trả về dữ liệu;
}

jQuery.extend ({
	hasData: function (elem) {
		trả về dataUser.hasData (elem) || dataPriv.hasData (elem);
	},

	data: function (elem, name, data) {
		trả về dataUser.access (elem, tên, dữ liệu);
	},

	removeData: function (elem, name) {
		dataUser.remove (elem, tên);
	},

	// VIỆC CẦN LÀM: Bây giờ tất cả các lệnh gọi tới _data và _removeData đã được thay thế
	// với các lệnh gọi trực tiếp đến các phương thức dataPriv, những phương thức này có thể không được dùng nữa.
	_data: function (elem, name, data) {
		trả về dataPriv.access (elem, tên, dữ liệu);
	},

	_removeData: function (elem, name) {
		dataPriv.remove (elem, tên);
	}
});

jQuery.fn.extend ({
	data: function (key, value) {
		var i, name, data,
			elem = this [0],
			attrs = elem && elem.attributes;

		// Nhận tất cả các giá trị
		if (key === undefined) {
			if (this.length) {
				data = dataUser.get (elem);

				if (elem.nodeType === 1 &&! dataPriv.get (elem, "hasDataAttrs")) {
					i = attrs.length;
					trong khi tôi-- ) {

						// Hỗ trợ: chỉ IE 11
						// Các phần tử đính kèm có thể là null (# 14894)
						if (attrs [i]) {
							name = attrs [i] .name;
							if (name.indexOf ("data-") === 0) {
								name = camelCase (name.slice (5));
								dataAttr (elem, tên, dữ liệu [tên]);
							}
						}
					}
					dataPriv.set (elem, "hasDataAttrs", true);
				}
			}

			trả về dữ liệu;
		}

		// Đặt nhiều giá trị
		if (typeof key === "object") {
			trả về this.each (function () {
				dataUser.set (this, key);
			});
		}

		trả lại quyền truy cập (cái này, hàm (giá trị) {
			dữ liệu var;

			// Đối tượng jQuery đang gọi (phần tử phù hợp) không trống
			// (và do đó có một phần tử xuất hiện tại [0] này) và
			// tham số `value` không được xác định. Một đối tượng jQuery trống
			// sẽ dẫn đến `undefined` cho elem = this [0], điều này sẽ
			// ném ra một ngoại lệ nếu một nỗ lực đọc một bộ nhớ cache dữ liệu được thực hiện.
			if (elem && value === undefined) {

				// Cố gắng lấy dữ liệu từ bộ nhớ đệm
				// Khóa sẽ luôn là camelCased in Data
				data = dataUser.get (elem, key);
				if (data! == undefined) {
					trả về dữ liệu;
				}

				// Cố gắng "khám phá" dữ liệu trong
				// Dữ liệu tùy chỉnh HTML5- * attrs
				data = dataAttr (elem, key);
				if (data! == undefined) {
					trả về dữ liệu;
				}

				// Chúng tôi đã rất cố gắng, nhưng dữ liệu không tồn tại.
				trở về;
			}

			// Đặt dữ liệu ...
			this.each (function () {

				// Chúng tôi luôn lưu trữ khóa camelCased
				dataUser.set (this, key, value);
			});
		}, null, giá trị, đối số.length> 1, null, true);
	},

	removeData: function (key) {
		trả về this.each (function () {
			dataUser.remove (this, key);
		});
	}
});


jQuery.extend ({
	queue: function (elem, type, data) {
		hàng đợi var;

		if (elem) {
			type = (type || "fx") + "queue";
			queue = dataPriv.get (elem, type);

			// Tăng tốc độ dequeue bằng cách thoát ra ngoài nhanh chóng nếu đây chỉ là tra cứu
			nếu (dữ liệu) {
				if (! queue || Array.isArray (data)) {
					queue = dataPriv.access (elem, type, jQuery.makeArray (data));
				} khác {
					queue.push (dữ liệu);
				}
			}
			hàng đợi trả về || [];
		}
	},

	dequeue: function (elem, type) {
		type = loại || "fx";

		var queue = jQuery.queue (elem, type),
			startLength = queue.length,
			fn = queue.shift (),
			hooks = jQuery._queueHooks (elem, type),
			next = function () {
				jQuery.dequeue (elem, type);
			};

		// Nếu hàng đợi fx bị xếp lại, hãy luôn xóa tiến trình sentinel
		if (fn === "inprogress") {
			fn = queue.shift ();
			startLength--;
		}

		nếu (fn) {

			// Thêm một sentinel tiến trình để ngăn hàng đợi fx
			// tự động giảm giá trị
			if (gõ === "fx") {
				queue.unshift ("đầu vào");
			}

			// Xóa hàm dừng hàng đợi cuối cùng
			xóa hooks.stop;
			fn.call (elem, next, hooks);
		}

		if (! startLength && hooks) {
			hooks.empty.fire ();
		}
	},

	// Không công khai - tạo đối tượng queueHooks hoặc trả về đối tượng hiện tại
	_queueHooks: function (elem, type) {
		var key = type + "queueHooks";
		trả về dataPriv.get (elem, key) || dataPriv.access (elem, key, {
			rỗng: jQuery.Callbacks ("bộ nhớ một lần") .add (function () {
				dataPriv.remove (elem, [type + "queue", key]);
			})
		});
	}
});

jQuery.fn.extend ({
	queue: function (type, data) {
		var setter = 2;

		if (typeof type! == "string") {
			data = kiểu;
			loại = "fx";
			người định cư--;
		}

		if (đối số.length <setter) {
			return jQuery.queue (this [0], type);
		}

		trả về dữ liệu === không xác định?
			cái này :
			this.each (function () {
				var queue = jQuery.queue (this, type, data);

				// Đảm bảo một móc cho hàng đợi này
				jQuery._queueHooks (this, type);

				if (type === "fx" && queue [0]! == "inprogress") {
					jQuery.dequeue (this, type);
				}
			});
	},
	dequeue: function (type) {
		trả về this.each (function () {
			jQuery.dequeue (this, type);
		});
	},
	clearQueue: function (type) {
		return this.queue (type || "fx", []);
	},

	// Nhận một lời hứa được giải quyết khi các hàng đợi thuộc một loại nhất định
	// được làm trống (fx là kiểu theo mặc định)
	hứa hẹn: function (type, obj) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred (),
			phần tử = cái này,
			i = this.length,
			giải quyết = function () {
				if (! (--count)) {
					defer.resolveWith (phần tử, [phần tử]);
				}
			};

		if (typeof type! == "string") {
			obj = loại;
			type = không xác định;
		}
		type = loại || "fx";

		trong khi tôi-- ) {
			tmp = dataPriv.get (element [i], type + "queueHooks");
			nếu (tmp && tmp.empty) {
				tính ++;
				tmp.empty.add (giải quyết);
			}
		}
		giải quyết();
		trả về defer.promise (obj);
	}
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/) .source;

var rcssNum = new RegExp ("^ (?: ([+ -]) = |) (" + pnum + ") ([az%] *) $", "i");


var cssExpand = ["Trên", "Phải", "Dưới", "Trái"];

var documentElement = document.documentElement;



	var isAttached = function (elem) {
			return jQuery.contains (elem.ownerDocument, elem);
		},
		sáng tác = {sáng tác: true};

	// Hỗ trợ: IE 9 - 11+, Edge 12 - 18+, chỉ iOS 10.0 - 10.2
	// Kiểm tra tệp đính kèm qua ranh giới DOM bóng khi có thể (gh-3504)
	// Hỗ trợ: chỉ iOS 10.0-10.2
	// Phiên bản iOS 10 đầu tiên hỗ trợ `AttachShadow` nhưng không hỗ trợ` getRootNode`,
	// dẫn đến lỗi. Chúng ta cần kiểm tra `getRootNode`.
	if (documentElement.getRootNode) {
		isAttached = function (elem) {
			trả về jQuery.contains (elem.ownerDocument, elem) ||
				elem.getRootNode (sáng tác) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function (elem, el) {

		// isHiddenWithinTree có thể được gọi từ hàm lọc jQuery #;
		// trong trường hợp đó, phần tử sẽ là đối số thứ hai
		elem = el || độ cao;

		// Kiểu nội tuyến vượt trội hơn tất cả
		trả về elem.style.display === "none" ||
			elem.style.display === "" &&

			// Nếu không, hãy kiểm tra kiểu tính toán
			// Hỗ trợ: Firefox <= 43 - 45
			// Các phần tử bị ngắt kết nối có thể có tính toán hiển thị: không có, vì vậy trước tiên hãy xác nhận rằng elem là
			// trong tài liệu.
			isAttached (elem) &&

			jQuery.css (elem, "display") === "none";
	};



chức năng điều chỉnhCSS (elem, prop, valueParts, tween) {
	var được điều chỉnh, tỷ lệ,
		maxIterations = 20,
		currentValue = tween?
			hàm số() {
				trả về tween.cur ();
			}:
			hàm số() {
				return jQuery.css (elem, prop, "");
			},
		ban đầu = currentValue (),
		unit = valueParts && valueParts [3] || (jQuery.cssNumber [prop]? "": "px"),

		// Bắt buộc phải tính toán giá trị bắt đầu cho các đơn vị có thể không khớp
		ban đầuInUnit = elem.nodeType &&
			(jQuery.cssNumber [prop] || unit! == "px" && + tên viết tắt) &&
			rcssNum.exec (jQuery.css (elem, prop));

	if (initialInUnit && initialInUnit [3]! == unit) {

		// Hỗ trợ: Firefox <= 54
		// Giảm một nửa giá trị mục tiêu lặp lại để ngăn chặn sự can thiệp từ các giới hạn trên của CSS (gh-2144)
		ban đầu = ban đầu / 2;

		// Đơn vị tin cậy được jQuery.css báo cáo
		unit = đơn vị || ban đầuInUnit [3];

		// Lặp lại gần đúng từ điểm bắt đầu khác không
		ban đầuInUnit = + ban đầu || 1;

		while (maxIterations--) {

			// Đánh giá và cập nhật dự đoán tốt nhất của chúng tôi (nhân đôi số dự đoán không ra).
			// Kết thúc nếu tỷ lệ bằng hoặc vượt qua 1 (làm cho sản phẩm cũ * mới không dương).
			jQuery.style (elem, prop, initialInUnit + đơn vị);
			if ((1 - scale) * (1 - (scale = currentValue () / ban đầu || 0,5)) <= 0) {
				maxIterations = 0;
			}
			ban đầuInUnit = ban đầuInUnit / quy mô;

		}

		ban đầuInUnit = ban đầuInUnit * 2;
		jQuery.style (elem, prop, initialInUnit + đơn vị);

		// Đảm bảo chúng tôi cập nhật các thuộc tính tween sau này
		valueParts = valueParts || [];
	}

	if (valueParts) {
		ban đầuInUnit = + ban đầuInUnit || + ký tự đầu || Số 0;

		// Áp dụng phần bù tương đối (+ = / - =) nếu được chỉ định
		đã điều chỉnh = valueParts [1]?
			ban đầuInUnit + (valueParts [1] + 1) * valueParts [2]:
			+ valueParts [2];
		nếu (mười bảy tuổi) {
			tween.unit = đơn vị;
			tween.start = initialInUnit;
			tween.end = đã điều chỉnh;
		}
	}
	điều chỉnh trở lại;
}


var defaultDisplayMap = {};

function getDefaultDisplay (elem) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap [nodeName];

	if (hiển thị) {
		trả lại màn hình;
	}

	temp = doc.body.appendChild (doc.createElement (nodeName));
	display = jQuery.css (temp, "display");

	temp.parentNode.removeChild (tạm thời);

	if (display === "none") {
		display = "khối";
	}
	defaultDisplayMap [nodeName] = display;

	trả lại màn hình;
}

function showHide (phần tử, hiển thị) {
	var display, elem,
		giá trị = [],
		chỉ mục = 0,
		length = các phần tử.length;

	// Xác định giá trị hiển thị mới cho các phần tử cần thay đổi
	for (; index <length; index ++) {
		elem = các phần tử [chỉ số];
		if (! elem.style) {
			tiếp tục;
		}

		display = elem.style.display;
		nếu (hiển thị) {

			// Vì chúng tôi buộc khả năng hiển thị dựa trên các phần tử ẩn theo tầng, nên ngay lập tức (và chậm)
			// kiểm tra là bắt buộc trong vòng lặp đầu tiên này trừ khi chúng tôi có giá trị hiển thị không có giá trị nào (hoặc
			// nội dòng hoặc sắp được khôi phục)
			if (display === "none") {
				giá trị [index] = dataPriv.get (elem, "display") || vô giá trị;
				if (! giá trị [chỉ mục]) {
					elem.style.display = "";
				}
			}
			if (elem.style.display === "" && isHiddenWithinTree (elem)) {
				giá trị [index] = getDefaultDisplay (elem);
			}
		} khác {
			if (display! == "none") {
				giá trị [index] = "không có";

				// Nhớ những gì chúng ta đang ghi đè
				dataPriv.set (elem, "hiển thị", hiển thị);
			}
		}
	}

	// Đặt hiển thị các phần tử trong vòng lặp thứ hai để tránh chỉnh lại liên tục
	for (index = 0; index <length; index ++) {
		if (giá trị [index]! = null) {
			các phần tử [chỉ mục] .style.display = giá trị [chỉ số];
		}
	}

	trả về các phần tử;
}

jQuery.fn.extend ({
	show: function () {
		return showHide (this, true);
	},
	ẩn: function () {
		return showHide (this);
	},
	chuyển đổi: chức năng (trạng thái) {
		if (typeof state === "boolean") {
			trở lại trạng thái? this.show (): this.hide ();
		}

		trả về this.each (function () {
			if (isHiddenWithinTree (this)) {
				jQuery (this) .show ();
			} khác {
				jQuery (this) .hide ();
			}
		});
	}
});
var rcheckableType = (/ ^ (?: hộp kiểm | radio) $ / i);

var rtagName = (/ <([az] [^ \ / \ 0> \ x20 \ t \ r \ n \ f] *) / i);

var rscriptType = (/ ^ $ | ^ module $ | \ / (?: java | ecma) script / i);



( hàm số() {
	var segment = document.createDocumentFragment (),
		div =gment.appendChild (document.createElement ("div")),
		input = document.createElement ("đầu vào");

	// Hỗ trợ: chỉ Android 4.0 - 4.3
	// Kiểm tra trạng thái bị mất nếu tên được đặt (# 11217)
	// Hỗ trợ: Ứng dụng web Windows (WWA)
	// `name` và` type` phải sử dụng .setAttribute cho WWA (# 14901)
	input.setAttribute ("type", "radio");
	input.setAttribute ("đã kiểm tra", "đã kiểm tra");
	input.setAttribute ("na me", "t");

	div.appendChild (đầu vào);

	// Chỉ hỗ trợ: Android <= 4.1
	// WebKit cũ hơn không sao chép chính xác trạng thái đã kiểm tra trong các đoạn
	support.checkClone = div.cloneNode (true) .cloneNode (true) .lastChild.checked;

	// Chỉ hỗ trợ: IE <= 11
	// Đảm bảo textarea (và hộp kiểm) defaultValue được sao chép đúng cách
	div.innerHTML = "<textareosystem x </textareosystem";
	support.noCloneChecked = !! div.cloneNode (true) .lastChild.defaultValue;

	// Chỉ hỗ trợ: IE <= 9
	// IE <= 9 thay thế các thẻ <option> bằng nội dung của chúng khi được chèn bên ngoài
	// phần tử chọn.
	div.innerHTML = "<option> </option>";
	support.option = !! div.lastChild;
}) ();


// Chúng tôi phải đóng các thẻ này để hỗ trợ XHTML (# 13200)
var wrapMap = {

	// Trình phân tích cú pháp XHTML không chèn các phần tử vào
	// giống như cách mà trình phân tích cú pháp thẻ súp làm. Vì vậy, chúng tôi không thể rút ngắn
	// điều này bằng cách bỏ qua <tbody> hoặc các phần tử bắt buộc khác.
	cái: [1, "<table>", "</table>"],
	col: [2, "<table> <colgroup>", "</colgroup> </table>"],
	tr: [2, "<table> <tbody>", "</tbody> </table>"],
	td: [3, "<table> <tbody> <tr>", "</tr> </tbody> </table>"],

	_default: [0, "", ""]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Chỉ hỗ trợ: IE <= 9
if (! support.option) {
	wrapMap.optgroup = wrapMap.option = [1, "<select multiple = 'multiple'>", "</select>"];
}


function getAll (context, tag) {

	// Chỉ hỗ trợ: IE <= 9 - 11
	// Sử dụng typeof để tránh lệnh gọi phương thức không đối số trên các đối tượng máy chủ (# 15151)
	var ret;

	if (typeof context.getElementsByTagName! == "undefined") {
		ret = context.getElementsByTagName (tag || "*");

	} else if (typeof context.querySelectorAll! == "undefined") {
		ret = context.querySelectorAll (tag || "*");

	} khác {
		ret = [];
	}

	if (tag === undefined || tag && nodeName (context, tag)) {
		return jQuery.merge ([context], ret);
	}

	trả lại ret;
}


// Đánh dấu các tập lệnh là đã được đánh giá
function setGlobalEval (elems, refElements) {
	var i = 0,
		l = chiều dài chiều cao;

	cho (; i <l; i ++) {
		dataPriv.set (
			elems [i],
			"globalEval",
			! cải tiến || dataPriv.get (refElements [i], "globalEval")
		);
	}
}


var rhtml = / <| & #? \ w +; /;

function buildFragment (elems, context, scripts, lựa chọn, bỏ qua) {
	var elem, tmp, tag, bọc, đính kèm, j,
		mảnh = context.createDocumentFragment (),
		các nút = [],
		i = 0,
		l = chiều dài chiều cao;

	cho (; i <l; i ++) {
		elem = elems [i];

		nếu (elem || elem === 0) {

			// Thêm trực tiếp các nút
			if (toType (elem) === "object") {

				// Hỗ trợ: chỉ Android <= 4.0, chỉ PhantomJS 1
				// push.apply (_, arraylike) ném trên WebKit cổ
				jQuery.merge (các nút, elem.nodeType? [elem]: elem);

			// Chuyển đổi không phải html thành nút văn bản
			} else if (! rhtml.test (elem)) {
				node.push (context.createTextNode (elem));

			// Chuyển đổi html thành các nút DOM
			} khác {
				tmp = tmp || mảnh.appendChild (context.createElement ("div"));

				// Hủy số hóa một biểu diễn tiêu chuẩn
				tag = (rtagName.exec (elem) || ["", ""]) [1] .toLowerCase ();
				wrap = wrapMap [tag] || wrapMap._default;
				tmp.innerHTML = wrap [1] + jQuery.htmlPrefilter (elem) + wrap [2];

				// Đi xuống qua các trình bao bọc đến đúng nội dung
				j = quấn [0];
				trong khi (j--) {
					tmp = tmp.lastChild;
				}

				// Hỗ trợ: chỉ Android <= 4.0, chỉ PhantomJS 1
				// push.apply (_, arraylike) ném trên WebKit cổ
				jQuery.merge (các nút, tmp.childNodes);

				// Nhớ vùng chứa cấp cao nhất
				tmp = mảnh.firstChild;

				// Đảm bảo rằng các nút đã tạo là không có (# 12392)
				tmp.textContent = "";
			}
		}
	}

	// Xóa trình bao bọc khỏi phân đoạn
	mảnh.textContent = "";

	i = 0;
	while ((elem = node [i ++])) {

		// Bỏ qua các phần tử đã có trong bộ sưu tập ngữ cảnh (trac-4087)
		if (selection && jQuery.inArray (elem, selection)> -1) {
			nếu (bị bỏ qua) {
				bỏ qua.push (elem);
			}
			tiếp tục;
		}

		đính kèm = isAttached (elem);

		// Nối vào phân mảnh
		tmp = getAll (mảnh.appendChild (elem), "script");

		// Lưu giữ lịch sử đánh giá tập lệnh
		nếu (đính kèm) {
			setGlobalEval (tmp);
		}

		// Chụp các tệp thực thi
		if (script) {
			j = 0;
			while ((elem = tmp [j ++])) {
				if (rscriptType.test (elem.type || "")) {
					scripts.push (elem);
				}
			}
		}
	}

	trả lại phân mảnh;
}


var
	rkeyEvent = / ^ key /,
	rmouseEvent = / ^ (?: mouse | pointer | contextmenu | drag | drop) | click /,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue () {
	trả về true;
}

function returnFalse () {
	trả về sai;
}

// Hỗ trợ: IE <= 9 - 11+
// focus () và fade () không đồng bộ, ngoại trừ khi chúng không hoạt động.
// Vì vậy, mong đợi tiêu điểm là đồng bộ khi phần tử đã hoạt động,
// và làm mờ trở thành đồng bộ khi phần tử chưa hoạt động.
// (tiêu điểm và làm mờ luôn đồng bộ trong các trình duyệt được hỗ trợ khác,
// điều này chỉ xác định khi nào chúng ta có thể tin tưởng vào nó).
functionpectSync (elem, type) {
	return (elem === safeActiveElement ()) === (loại === "tiêu điểm");
}

// Chỉ hỗ trợ: IE <= 9
// Truy cập document.activeElement có thể ném bất ngờ
// https://bugs.jquery.com/ticket/13393
function safeActiveElement () {
	thử {
		trả về document.activeElement;
	} bắt (lỗi) {}
}

chức năng bật (elem, các loại, bộ chọn, dữ liệu, fn, một) {
	var origFn, loại;

	// Các kiểu có thể là một bản đồ của các kiểu / trình xử lý
	if (typeof styles === "object") {

		// (các kiểu-Đối tượng, bộ chọn, dữ liệu)
		if (typeof selector! == "string") {

			// (các kiểu-Đối tượng, dữ liệu)
			data = dữ liệu || bộ chọn;
			selector = undefined;
		}
		for (gõ các loại) {
			on (elem, type, selector, data, type [type], one);
		}
		trả lại elem;
	}

	if (data == null && fn == null) {

		// (loại, fn)
		fn = bộ chọn;
		data = selector = undefined;
	} else if (fn == null) {
		if (typeof selector === "string") {

			// (loại, bộ chọn, fn)
			fn = dữ liệu;
			dữ liệu = không xác định;
		} khác {

			// (loại, dữ liệu, fn)
			fn = dữ liệu;
			data = bộ chọn;
			selector = undefined;
		}
	}
	if (fn === false) {
		fn = returnFalse;
	} else if (! fn) {
		trả lại elem;
	}

	nếu (một === 1) {
		origFn = fn;
		fn = function (event) {

			// Có thể sử dụng một tập hợp trống, vì sự kiện chứa thông tin
			jQuery (). off (sự kiện);
			return origFn.apply (this, các đối số);
		};

		// Sử dụng cùng một hướng dẫn để người gọi có thể xóa bằng cách sử dụng origFn
		fn.guid = origFn.guid || (origFn.guid = jQuery.guid ++);
	}
	trả về elem.each (function () {
		jQuery.event.add (this, type, fn, data, selector);
	});
}

/ *
 * Chức năng của người trợ giúp để quản lý các sự kiện - không phải là một phần của giao diện công khai.
 * Đạo cụ đến thư viện addEvent của Dean Edwards cho nhiều ý tưởng.
 * /
jQuery.event = {

	toàn cầu: {},

	thêm: hàm (elem, các loại, trình xử lý, dữ liệu, bộ chọn) {

		var handleObjIn, eventHandle, tmp,
			sự kiện, t, handleObj,
			đặc biệt, trình xử lý, loại, không gian tên, origType,
			elemData = dataPriv.get (elem);

		// Chỉ đính kèm sự kiện vào các đối tượng chấp nhận dữ liệu
		if (! acceptData (elem)) {
			trở về;
		}

		// Người gọi có thể chuyển một đối tượng của dữ liệu tùy chỉnh thay cho trình xử lý
		if (handler.handler) {
			handleObjIn = trình xử lý;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Đảm bảo rằng các bộ chọn không hợp lệ ném ra các ngoại lệ tại thời điểm đính kèm
		// Đánh giá dựa trên documentElement trong trường hợp elem là một nút không phải phần tử (ví dụ: tài liệu)
		if (bộ chọn) {
			jQuery.find.matchesSelector (documentElement, bộ chọn);
		}

		// Đảm bảo rằng trình xử lý có một ID duy nhất, được sử dụng để tìm / xóa nó sau này
		if (! handler.guid) {
			handler.guid = jQuery.guid ++;
		}

		// Init cấu trúc sự kiện của phần tử và trình xử lý chính, nếu đây là phần tử đầu tiên
		if (! (events = elemData.events)) {
			sự kiện = elemData.events = Object.create (null);
		}
		if (! (eventHandle = elemData.handle)) {
			eventHandle = elemData.handle = function (e) {

				// Loại bỏ sự kiện thứ hai của jQuery.event.trigger () và
				// khi một sự kiện được gọi sau khi một trang đã được tải xuống
				return typeof jQuery! == "undefined" && jQuery.event.triggered! == e.type?
					jQuery.event.dispatch.apply (elem, đối số): undefined;
			};
		}

		// Xử lý nhiều sự kiện được phân tách bằng dấu cách
		các loại = (loại || "") .match (rnothtmlwhite) || [""];
		t = các loại. độ dài;
		trong khi (t--) {
			tmp = rtypenamespace.exec (các loại [t]) || [];
			type = origType = tmp [1];
			namespaces = (tmp [2] || "") .split (".") .sort ();

			// Có * phải * là một kiểu, không đính kèm các trình xử lý chỉ dành cho không gian tên
			if (! type) {
				tiếp tục;
			}

			// Nếu sự kiện thay đổi kiểu của nó, hãy sử dụng trình xử lý sự kiện đặc biệt cho kiểu đã thay đổi
			đặc biệt = jQuery.event.special [type] || {};

			// Nếu bộ chọn được xác định, hãy xác định loại api sự kiện đặc biệt, nếu không thì loại đã cho
			type = (selector? special.delegateType: special.bindType) || gõ phím;

			// Cập nhật đặc biệt dựa trên loại mới đặt lại
			đặc biệt = jQuery.event.special [type] || {};

			// handleObj được chuyển cho tất cả các trình xử lý sự kiện
			handleObj = jQuery.extend ({
				type: loại,
				origType: origType,
				data: dữ liệu,
				handler: người xử lý,
				hướng dẫn: handler.guid,
				selector: bộ chọn,
				needContext: selector && jQuery.expr.match.needsContext.test (bộ chọn),
				không gian tên: namespaces.join (".")
			}, handleObjIn);

			// Sắp xếp hàng đợi trình xử lý sự kiện nếu chúng ta là người đầu tiên
			if (! (xử lý = sự kiện [type])) {
				xử lý = sự kiện [type] = [];
				xử lý.delegateCount = 0;

				// Chỉ sử dụng addEventListener nếu trình xử lý sự kiện đặc biệt trả về false
				if (! special.setup ||
					special.setup.call (elem, data, namespace, eventHandle) === false) {

					if (elem.addEventListener) {
						elem.addEventListener (type, eventHandle);
					}
				}
			}

			if (special.add) {
				special.add.call (elem, handleObj);

				if (! handleObj.handler.guid) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Thêm vào danh sách trình xử lý của phần tử, đại biểu ở phía trước
			if (bộ chọn) {
				handlers.splice (handlers.delegateCount ++, 0, handleObj);
			} khác {
				handlers.push (handleObj);
			}

			// Theo dõi những sự kiện nào đã từng được sử dụng, để tối ưu hóa sự kiện
			jQuery.event.global [type] = true;
		}

	},

	// Tách một sự kiện hoặc tập hợp các sự kiện khỏi một phần tử
	remove: function (elem, styles, handler, selector, mappedTypes) {

		var j, origCount, tmp,
			sự kiện, t, handleObj,
			đặc biệt, trình xử lý, loại, không gian tên, origType,
			elemData = dataPriv.hasData (elem) && dataPriv.get (elem);

		if (! elemData ||! (events = elemData.events)) {
			trở về;
		}

		// Một lần cho mỗi type.namespace trong các loại; loại có thể bị bỏ qua
		các loại = (loại || "") .match (rnothtmlwhite) || [""];
		t = các loại. độ dài;
		trong khi (t--) {
			tmp = rtypenamespace.exec (các loại [t]) || [];
			type = origType = tmp [1];
			namespaces = (tmp [2] || "") .split (".") .sort ();

			// Bỏ liên kết tất cả các sự kiện (trên không gian tên này, nếu được cung cấp) cho phần tử
			if (! type) {
				for (nhập sự kiện) {
					jQuery.event.remove (elem, type + type [t], handler, selector, true);
				}
				tiếp tục;
			}

			đặc biệt = jQuery.event.special [type] || {};
			type = (selector? special.delegateType: special.bindType) || gõ phím;
			xử lý = sự kiện [loại] || [];
			tmp = tmp [2] &&
				new RegExp ("(^ | \\.)" + namespaces.join ("\\. (?:. * \\. |)") + "(\\. | $)");

			// Xóa các sự kiện phù hợp
			origCount = j = handlers.length;
			trong khi (j--) {
				handleObj = xử lý [j];

				if ((mappedTypes || origType === handleObj.origType) &&
					(! handler || handler.guid === handleObj.guid) &&
					(! tmp || tmp.test (handleObj.namespace)) &&
					(! selector || selector === handleObj.selector ||
						bộ chọn === "**" && handleObj.selector)) {
					xử lý.splice (j, 1);

					if (handleObj.selector) {
						Xử lý.delegateCount--;
					}
					if (special.remove) {
						special.remove.call (elem, handleObj);
					}
				}
			}

			// Xóa trình xử lý sự kiện chung nếu chúng tôi đã xóa thứ gì đó và không còn trình xử lý nào nữa
			// (tránh khả năng xảy ra đệ quy vô tận trong khi xóa các trình xử lý sự kiện đặc biệt)
			if (origCount &&! handlers.length) {
				if (! special.teardown ||
					special.teardown.call (elem, namespaces, elemData.handle) === false) {

					jQuery.removeEvent (elem, type, elemData.handle);
				}

				xóa sự kiện [loại];
			}
		}

		// Xóa dữ liệu và phần mở rộng nếu nó không còn được sử dụng
		if (jQuery.isEmptyObject (sự kiện)) {
			dataPriv.remove (elem, "xử lý các sự kiện");
		}
	},

	Dispatch: function (nativeEvent) {

		var i, j, ret, đã khớp, handleObj, handlerQueue,
			args = mảng mới (đối số.length),

			// Tạo một jQuery.Event có thể ghi từ đối tượng sự kiện gốc
			event = jQuery.event.fix (nativeEvent),

			người xử lý = (
					dataPriv.get (this, "sự kiện") || Object.create (null)
				) [event.type] || [],
			special = jQuery.event.special [event.type] || {};

		// Sử dụng jQuery.Event sửa chữa thay vì sự kiện gốc (chỉ đọc)
		args [0] = sự kiện;

		cho (i = 1; i <đối số.length; i ++) {
			args [i] = đối số [i];
		}

		event.delegateTarget = this;

		// Gọi hook preDispatch cho kiểu được ánh xạ và để nó tại ngoại nếu muốn
		if (special.preDispatch && special.preDispatch.call (this, event) === false) {
			trở về;
		}

		// Xác định trình xử lý
		handlerQueue = jQuery.event.handlers.call (this, sự kiện, các trình xử lý);

		// Chạy đại biểu trước; họ có thể muốn ngừng truyền bá bên dưới chúng ta
		i = 0;
		while ((match = handlerQueue [i ++]) &&! event.isPropagationStopped ()) {
			event.currentTarget = match.elem;

			j = 0;
			while ((handleObj = match.handlers [j ++]) &&
				! event.isIm InstantPropagationStopped ()) {

				// Nếu sự kiện có không gian tên, thì mỗi trình xử lý chỉ được gọi nếu nó
				// phổ biến đặc biệt hoặc không gian tên của nó là một tập hợp siêu của sự kiện.
				if (! event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test (handleObj.namespace)) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ((jQuery.event.special [handleObj.origType] || {}) .handle ||
						handleObj.handler) .apply (match.elem, args);

					if (ret! == undefined) {
						if ((event.result = ret) === false) {
							event.preventDefault ();
							event.stopPropagation ();
						}
					}
				}
			}
		}

		// Gọi hook postDispatch cho kiểu được ánh xạ
		if (special.postDispatch) {
			special.postDispatch.call (this, event);
		}

		return event.result;
	},

	xử lý: hàm (sự kiện, trình xử lý) {
		var i, handleObj, sel, matchHandlers, matchSelectors,
			handlerQueue = [],
			DelegateCount = handlers.delegateCount,
			cur = event.target;

		// Tìm trình xử lý ủy quyền
		if (Đại biểu &&

			// Hỗ trợ: IE <= 9
			// Cây cá thể SVG <use> lỗ đen (trac-13180)
			cur.nodeType &&

			// Hỗ trợ: Firefox <= 42
			// Loại bỏ các nhấp chuột vi phạm đặc điểm cho biết nút không phải con trỏ chính (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Hỗ trợ: chỉ IE 11
			// ... nhưng không phải phím mũi tên "nhấp" vào đầu vào radio, có thể có `nút` -1 (gh-2343)
			! (event.type === "click" && event.button> = 1)) {

			for (; cur! == this; cur = cur.parentNode || this) {

				// Không kiểm tra các phần tử không phải (# 13208)
				// Không xử lý nhấp chuột vào các phần tử bị vô hiệu hóa (# 6911, # 8165, # 11382, # 11764)
				if (cur.nodeType === 1 &&! (event.type === "click" && cur.disabled === true)) {
					matchHandlers = [];
					matchSelectors = {};
					for (i = 0; i <DelegateCount; i ++) {
						handleObj = xử lý [i];

						// Không xung đột với thuộc tính Object.prototype (# 13203)
						sel = handleObj.selector + "";

						if (matchSelectors [sel] === undefined) {
							matchSelectors [sel] = handleObj.needsContext?
								jQuery (sel, this) .index (cur)> -1:
								jQuery.find (sel, this, null, [cur]) .length;
						}
						if (matchSelectors [sel]) {
							matchHandlers.push (handleObj);
						}
					}
					if (matchHandlers.length) {
						handlerQueue.push ({elem: cur, xử lý: matchHandlers});
					}
				}
			}
		}

		// Thêm các trình xử lý (liên kết trực tiếp) còn lại
		cur = cái này;
		if (MemberCount <handlers.length) {
			handlerQueue.push ({elem: cur, handlers: handlers.slice (DeleCount)});
		}

		return handlerQueue;
	},

	addProp: function (name, hook) {
		Object.defineProperty (jQuery.Event.prototype, tên, {
			enumerable: true,
			có thể định cấu hình: true,

			get: isFunction (hook)?
				hàm số() {
					if (this.originalEvent) {
							trả về móc câu (this.originalEvent);
					}
				}:
				hàm số() {
					if (this.originalEvent) {
							return this.originalEvent [name];
					}
				},

			set: function (value) {
				Object.defineProperty (cái này, tên, {
					enumerable: true,
					có thể định cấu hình: true,
					có thể ghi: true,
					value: giá trị
				});
			}
		});
	},

	fix: function (originalEvent) {
		trả về originalEvent [jQuery.expando]?
			originalEvent:
			jQuery.Event mới (originalEvent);
	},

	đặc biệt: {
		trọng tải: {

			// Ngăn chặn các sự kiện image.load được kích hoạt chuyển sang window.load
			noBubble: true
		},
		nhấp chuột: {

			// Sử dụng sự kiện gốc để đảm bảo trạng thái chính xác cho các đầu vào có thể kiểm tra
			setup: function (data) {

				// Để có thể nén lẫn nhau với _default, hãy thay thế quyền truy cập `this` bằng một var cục bộ.
				// `|| data` là mã chết chỉ có nghĩa là để bảo toàn biến thông qua việc rút gọn.
				var el = this || dữ liệu;

				// Xác nhận trình xử lý đầu tiên
				if (rcheckableType.test (el.type) &&
					el.click && nodeName (el, "input")) {

					// dataPriv.set (el, "click", ...)
					leverageNative (el, "click", returnTrue);
				}

				// Trả về false để cho phép xử lý bình thường trong trình gọi
				trả về sai;
			},
			trigger: hàm (dữ liệu) {

				// Để có thể nén lẫn nhau với _default, hãy thay thế quyền truy cập `this` bằng một var cục bộ.
				// `|| data` là mã chết chỉ có nghĩa là để bảo toàn biến thông qua việc rút gọn.
				var el = this || dữ liệu;

				// Buộc thiết lập trước khi kích hoạt một cú nhấp chuột
				if (rcheckableType.test (el.type) &&
					el.click && nodeName (el, "input")) {

					leverageNative (el, "nhấp chuột");
				}

				// Trả về giá trị không false để cho phép lan truyền đường dẫn sự kiện bình thường
				trả về true;
			},

			// Để có tính nhất quán trên nhiều trình duyệt, hãy loại bỏ .click () gốc trên các liên kết
			// Cũng ngăn chặn nó nếu chúng ta hiện đang ở trong một ngăn xếp sự kiện gốc có đòn bẩy
			_default: function (event) {
				var target = event.target;
				trả về rcheckableType.test (target.type) &&
					target.click && nodeName (target, "input") &&
					dataPriv.get (target, "click") ||
					nodeName (target, "a");
			}
		},

		tải trước: {
			postDispatch: function (sự kiện) {

				// Hỗ trợ: Firefox 20+
				// Firefox không cảnh báo nếu trường returnValue không được đặt.
				if (event.result! == undefined && event.originalEvent) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Đảm bảo sự hiện diện của trình xử lý sự kiện xử lý được kích hoạt thủ công
// sự kiện tổng hợp bằng cách làm gián đoạn tiến trình cho đến khi được gọi lại để phản hồi
// các sự kiện * native * mà nó kích hoạt trực tiếp, đảm bảo rằng các thay đổi trạng thái có
// đã xảy ra trước khi các trình nghe khác được gọi.
function leverageNative (el, type ,pectSync) {

	// Thiếu mong đợiSync chỉ ra một cuộc gọi kích hoạt, phải bắt buộc thiết lập thông qua jQuery.event.add
	if (! hopeSync) {
		if (dataPriv.get (el, type) === undefined) {
			jQuery.event.add (el, type, returnTrue);
		}
		trở về;
	}

	// Đăng ký bộ điều khiển như một trình xử lý chung đặc biệt cho tất cả các không gian tên sự kiện
	dataPriv.set (el, type, false);
	jQuery.event.add (el, type, {
		không gian tên: false,
		xử lý: function (event) {
			var notAsync, kết quả,
				save = dataPriv.get (this, type);

			if ((event.isTrigger & 1) && this [type]) {

				// Xử lý gián đoạn sự kiện .trigger () ed tổng hợp bên ngoài
				// Dữ liệu đã lưu phải là false trong những trường hợp như vậy, nhưng có thể là một đối tượng chụp còn sót lại
				// từ một trình xử lý gốc không đồng bộ (gh-4350)
				if (! save.length) {

					// Lưu trữ các đối số để sử dụng khi xử lý sự kiện gốc bên trong
					// Sẽ luôn có ít nhất một đối số (một đối tượng sự kiện), vì vậy mảng này
					// sẽ không bị nhầm lẫn với một đối tượng chụp còn sót lại.
					save = slice.call (các đối số);
					dataPriv.set (this, type, save);

					// Kích hoạt sự kiện gốc và ghi lại kết quả của nó
					// Hỗ trợ: IE <= 9 - 11+
					// tiêu điểm () và mờ () không đồng bộ
					notAsync = hopeSync (this, type);
					loại này ]();
					result = dataPriv.get (this, type);
					if (đã lưu! == kết quả || notAsync) {
						dataPriv.set (this, type, false);
					} khác {
						kết quả = {};
					}
					if (đã lưu! == kết quả) {

						// Hủy sự kiện tổng hợp bên ngoài
						event.stopIm InstantPropagation ();
						event.preventDefault ();
						trả về kết quả.value;
					}

				// Nếu đây là một sự kiện tổng hợp bên trong cho một sự kiện có thay thế nổi bọt
				// (tiêu điểm hoặc làm mờ), giả sử rằng vật thay thế đã được truyền từ việc kích hoạt
				// sự kiện gốc và ngăn điều đó xảy ra lần nữa tại đây.
				// Về mặt kỹ thuật, điều này làm sai trật tự wrt thành `.trigger ()` (trong đó
				// phần tử thay thế sủi bọt lan truyền * sau * phần gốc không sủi bọt), nhưng điều đó có vẻ như
				// ít tệ hơn sự trùng lặp.
				} else if ((jQuery.event.special [type] || {}) .delegateType) {
					event.stopPropagation ();
				}

			// Nếu đây là một sự kiện gốc được kích hoạt ở trên, mọi thứ hiện theo thứ tự
			// Kích hoạt một sự kiện tổng hợp bên trong với các đối số ban đầu
			} else if (save.length) {

				// ... và chụp kết quả
				dataPriv.set (this, type, {
					giá trị: jQuery.event.trigger (

						// Hỗ trợ: IE <= 9 - 11+
						// Mở rộng với nguyên mẫu để đặt lại stopIm InstantPropagation () ở trên
						jQuery.extend (đã lưu [0], jQuery.Event.prototype),
						save.slice (1),
						cái này
					)
				});

				// Hủy xử lý sự kiện gốc
				event.stopIm InstantPropagation ();
			}
		}
	});
}

jQuery.removeEvent = function (elem, type, handle) {

	// "Nếu" này là cần thiết cho các đối tượng thuần túy
	if (elem.removeEventListener) {
		elem.removeEventListener (loại, xử lý);
	}
};

jQuery.Event = function (src, props) {

	// Cho phép tạo mà không có từ khóa 'mới'
	if (! (this instanceof jQuery.Event)) {
		trả về jQuery.Event mới (src, props);
	}

	// Đối tượng sự kiện
	if (src && src.type) {
		this.originalEvent = src;
		this.type = src.type;

		// Các sự kiện xảy ra trong tài liệu có thể đã được đánh dấu là đã được ngăn chặn
		// bởi một trình xử lý hạ thấp cây; phản ánh đúng giá trị.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === không xác định &&

				// Hỗ trợ: chỉ dành cho Android <= 2.3
				src.returnValue === sai?
			returnTrue:
			returnFalse;

		// Tạo thuộc tính đích
		// Chỉ hỗ trợ: Safari <= 6 - 7
		// Đích không được là một nút văn bản (# 504, # 13143)
		this.target = (src.target && src.target.nodeType === 3)?
			src.target.parentNode:
			src.target;

		this.currentTarget = src.currentTarget;
		this.osystemTarget = src.osystemTarget;

	// Loại sự kiện
	} khác {
		this.type = src;
	}

	// Đặt các thuộc tính được cung cấp rõ ràng vào đối tượng sự kiện
	if (đạo cụ) {
		jQuery.extend (this, props);
	}

	// Tạo dấu thời gian nếu sự kiện đến không có
	this.timeStamp = src && src.timeStamp || Date.now ();

	// Đánh dấu là đã sửa
	this [jQuery.expando] = true;
};

// jQuery.Event dựa trên Sự kiện DOM3 như được chỉ định bởi Liên kết ngôn ngữ ECMAScript
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	hàm tạo: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isIm InstantPropagationStopped: returnFalse,
	isSimulated: false,

	PreventDefault: function () {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if (e &&! this.isSimulated) {
			e.preventDefault ();
		}
	},
	stopPropagation: function () {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if (e &&! this.isSimulated) {
			e.stopPropagation ();
		}
	},
	stopIm InstantPropagation: function () {
		var e = this.originalEvent;

		this.isIm InstantPropagationStopped = returnTrue;

		if (e &&! this.isSimulated) {
			e.stopIm InstantPropagation ();
		}

		this.stopPropagation ();
	}
};

// Bao gồm tất cả các đạo cụ sự kiện phổ biến bao gồm các đạo cụ cụ thể của KeyEvent và MouseEvent
jQuery.each ({
	altKey: true,
	bong bóng: đúng,
	có thể hủy bỏ: true,
	ChangeTouches: true,
	ctrlKey: true,
	chi tiết: đúng,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: đúng,
	xem: đúng,
	"char": true,
	mã: true,
	charCode: true,
	key: true,
	keyCode: true,
	nút: đúng,
	các nút: true,
	clientX: true,
	khách hàngY: đúng,
	offsetX: đúng,
	offsetY: đúng,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: đúng,
	cảm ứng: đúng,

	which: function (sự kiện) {
		var button = event.button;

		// Thêm cái nào cho các sự kiện quan trọng
		if (event.which == null && rkeyEvent.test (event.type)) {
			trả về event.charCode! = null? event.charCode: event.keyCode;
		}

		// Thêm cái nào cho lần nhấp: 1 === left; 2 === giữa; 3 === đúng
		if (! event.which && button! == undefined && rmouseEvent.test (event.type)) {
			if (nút & 1) {
				trả về 1;
			}

			if (nút & 2) {
				trả về 3;
			}

			if (nút & 4) {
				trả về 2;
			}

			trả về 0;
		}

		return event.which;
	}
}, jQuery.event.addProp);

jQuery.each ({focus: "focusin", mờ: "focusout"}, function (type, DelegateType) {
	jQuery.event.special [type] = {

		// Sử dụng sự kiện gốc nếu có thể để trình tự làm mờ / tiêu điểm là chính xác
		thiết lập: function () {

			// Xác nhận trình xử lý đầu tiên
			// dataPriv.set (this, "focus", ...)
			// dataPriv.set (this, "dim", ...)
			leverageNative (this, type, hopeSync);

			// Trả về false để cho phép xử lý bình thường trong trình gọi
			trả về sai;
		},
		trigger: function () {

			// Buộc thiết lập trước khi kích hoạt
			leverageNative (cái này, loại);

			// Trả về giá trị không false để cho phép lan truyền đường dẫn sự kiện bình thường
			trả về true;
		},

		DelegateType: DelegateType
	};
});

// Tạo sự kiện mouseenter / left bằng cách sử dụng mouseover / out và kiểm tra thời gian sự kiện
// để ủy quyền sự kiện hoạt động trong jQuery.
// Làm tương tự cho pointerenter / pointerleave và pointerover / pointerout
//
// Hỗ trợ: chỉ Safari 7
// Safari gửi mouseenter quá thường xuyên; xem:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// để biết mô tả về lỗi (lỗi này cũng tồn tại trong các phiên bản Chrome cũ hơn).
jQuery.each ({
	mouseenter: "di chuột qua",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function (orig, fix) {
	jQuery.event.special [orig] = {
		DelegateType: sửa chữa,
		bindType: sửa chữa,

		xử lý: function (sự kiện) {
			var ret,
				target = cái này,
				liên quan = event.osystemTarget,
				handleObj = event.handleObj;

			// Đối với mouseenter / left, gọi trình xử lý nếu liên quan nằm ngoài mục tiêu.
			// NB: Không có Mục tiêu liên quan nếu chuột rời / vào cửa sổ trình duyệt
			if (! Related || (liên quan! == target &&! jQuery.contains (target, liên quan))) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply (this, các đối số);
				event.type = sửa chữa;
			}
			trả lại ret;
		}
	};
});

jQuery.fn.extend ({

	on: function (type, selector, data, fn) {
		return on (this, type, selector, data, fn);
	},
	một: hàm (loại, bộ chọn, dữ liệu, fn) {
		return on (this, type, selector, data, fn, 1);
	},
	tắt: chức năng (loại, bộ chọn, fn) {
		var handleObj, loại;
		if (loại && loại.preventDefault && loại.handleObj) {

			// (sự kiện) gửi jQuery.Event
			handleObj = styles.handleObj;
			jQuery (styles.delegateTarget) .off (
				handleObj.namespace?
					handleObj.origType + "." + handleObj.namespace:
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			trả lại cái này;
		}
		if (typeof styles === "object") {

			// (các kiểu-đối tượng [, bộ chọn])
			for (gõ các loại) {
				this.off (loại, bộ chọn, loại [loại]);
			}
			trả lại cái này;
		}
		if (selector === false || typeof selector === "function") {

			// (loại [, fn])
			fn = bộ chọn;
			selector = undefined;
		}
		if (fn === false) {
			fn = returnFalse;
		}
		trả về this.each (function () {
			jQuery.event.remove (this, type, fn, selector);
		});
	}
});


var

	// Chỉ hỗ trợ: IE <= 10 - 11, Edge 12 - 13
	// Trong IE / Edge sử dụng các nhóm regex ở đây gây ra hiện tượng chậm máy nghiêm trọng.
	// Xem https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = / <script | <style | <link / i,

	// đã kiểm tra = "đã kiểm tra" hoặc đã kiểm tra
	rchecked = /checked\s*(?:[[^=]|=\s*.checked.)/i,
	rcleanScript = / ^ \ s * <! (?: \ [CDATA \ [| -) | (?: \] \] | -)> \ s * $ / g;

// Thích một tbody hơn bảng cha của nó để chứa các hàng mới
thao tác hàmTarget (elem, content) {
	if (nodeName (elem, "table") &&
		nodeName (content.nodeType! == 11? content: content.firstChild, "tr")) {

		trả về jQuery (elem) .children ("tbody") [0] || độ cao;
	}

	trả lại elem;
}

// Thay thế / khôi phục thuộc tính type của các phần tử script để thao tác DOM an toàn
function disableScript (elem) {
	elem.type = (elem.getAttribute ("loại")! == null) + "/" + elem.type;
	trả lại elem;
}
function restoreScript (elem) {
	if ((elem.type || "") .slice (0, 5) === "true /") {
		elem.type = elem.type.slice (5);
	} khác {
		elem.removeAttribute ("loại");
	}

	trả lại elem;
}

function cloneCopyEvent (src, dest) {
	var i, l, type, pdataOld, udataOld, udataCur, sự kiện;

	if (dest.nodeType! == 1) {
		trở về;
	}

	// 1. Sao chép dữ liệu cá nhân: sự kiện, trình xử lý, v.v.
	if (dataPriv.hasData (src)) {
		pdataOld = dataPriv.get (src);
		sự kiện = pdataOld.events;

		if (sự kiện) {
			dataPriv.remove (dest, "xử lý các sự kiện");

			for (nhập sự kiện) {
				for (i = 0, l = event [type] .length; i <l; i ++) {
					jQuery.event.add (dest, kiểu, sự kiện [kiểu] [i]);
				}
			}
		}
	}

	// 2. Sao chép dữ liệu người dùng
	if (dataUser.hasData (src)) {
		udataOld = dataUser.access (src);
		udataCur = jQuery.extend ({}, udataOld);

		dataUser.set (dest, udataCur);
	}
}

// Sửa lỗi IE, xem các bài kiểm tra hỗ trợ
function fixInput (src, dest) {
	var nodeName = dest.nodeName.toLowerCase ();

	// Không thể duy trì trạng thái đã chọn của hộp kiểm được sao chép hoặc nút radio.
	if (nodeName === "input" && rcheckableType.test (src.type)) {
		dest.checked = src.checked;

	// Không trả được tùy chọn đã chọn về trạng thái đã chọn mặc định khi nhân bản tùy chọn
	} else if (nodeName === "input" || nodeName === "textarea") {
		dest.defaultValue = src.defaultValue;
	}
}

hàm domManip (bộ sưu tập, args, gọi lại, bị bỏ qua) {

	// Làm phẳng mọi mảng lồng nhau
	args = phẳng (args);

	var segment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args [0],
		valueIsFunction = isFunction (giá trị);

	// Chúng tôi không thể cloneNode các đoạn có chứa đã kiểm tra, trong WebKit
	if (valueIsFunction ||
			(l> 1 && typeof value === "string" &&
				! support.checkClone && rchecked.test (value))) {
		return collection.each (function (index) {
			var self = collection.eq (index);
			if (valueIsFunction) {
				args [0] = value.call (this, index, self.html ());
			}
			domManip (tự, args, gọi lại, bị bỏ qua);
		});
	}

	nếu (l) {
		mảnh = buildFragment (args, collection [0] .ownerDocument, false, collection, bỏ qua);
		đầu tiên = mảnh.firstChild;

		if (segment.childNodes.length === 1) {
			mảnh = đầu tiên;
		}

		// Yêu cầu nội dung mới hoặc sự quan tâm đến các phần tử bị bỏ qua để gọi ra lệnh gọi lại
		if (đầu tiên || bị bỏ qua) {
			scripts = jQuery.map (getAll (segment, "script"), disableScript);
			hasScripts = scripts.length;

			// Sử dụng đoạn gốc cho mục cuối cùng
			// thay vì đầu tiên vì nó có thể kết thúc
			// được làm trống không chính xác trong một số trường hợp nhất định (# 8070).
			cho (; i <l; i ++) {
				nút = phân mảnh;

				if (i! == iNoClone) {
					node = jQuery.clone (node, true, true);

					// Giữ các tham chiếu đến các tập lệnh được sao chép để phục hồi sau này
					if (hasScripts) {

						// Hỗ trợ: chỉ Android <= 4.0, chỉ PhantomJS 1
						// push.apply (_, arraylike) ném trên WebKit cổ
						jQuery.merge (scripts, getAll (node, "script"));
					}
				}

				callback.call (collection [i], node, i);
			}

			if (hasScripts) {
				doc = scripts [scripts.length - 1] .ownerDocument;

				// Kích hoạt lại các tập lệnh
				jQuery.map (script, restoreScript);

				// Đánh giá các tập lệnh thực thi khi chèn tài liệu đầu tiên
				for (i = 0; i <hasScripts; i ++) {
					node = scripts [i];
					if (rscriptType.test (node.type || "") &&
						! dataPriv.access (nút, "globalEval") &&
						jQuery.contains (doc, node)) {

						if (node.src && (node.type || "") .toLowerCase ()! == "module") {

							// Tùy chọn AJAX tùy chọn, nhưng sẽ không chạy các tập lệnh nếu không có
							if (jQuery._evalUrl &&! node.noModule) {
								jQuery._evalUrl (node.src, {
									nonce: node.nonce || node.getAttribute ("nonce")
								}, doc);
							}
						} khác {
							DOMEval (node.textContent.replace (rcleanScript, ""), node, doc);
						}
					}
				}
			}
		}
	}

	trả lại bộ sưu tập;
}

chức năng loại bỏ (elem, selector, keepData) {
	nút var,
		các nút = bộ chọn? jQuery.filter (bộ chọn, elem): elem,
		i = 0;

	for (; (node ​​= node [i])! = null; i ++) {
		if (! keepData && node.nodeType === 1) {
			jQuery.cleanData (getAll (nút));
		}

		if (node.parentNode) {
			if (keepData && isAttached (node)) {
				setGlobalEval (getAll (nút, "tập lệnh"));
			}
			node.parentNode.removeChild (nút);
		}
	}

	trả lại elem;
}

jQuery.extend ({
	htmlPrefilter: function (html) {
		trả về html;
	},

	clone: ​​function (elem, dataAndEvents, deepDataAndEvents) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode (true),
			inPage = isAttached (elem);

		// Khắc phục sự cố sao chép IE
		if (! support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) &&
				! jQuery.isXMLDoc (elem)) {

			// Chúng tôi tránh Sizzle ở đây vì lý do hiệu suất: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll (nhân bản);
			srcElements = getAll (elem);

			for (i = 0, l = srcElements.length; i <l; i ++) {
				fixInput (srcElements [i], destElements [i]);
			}
		}

		// Sao chép các sự kiện từ bản gốc sang bản sao
		if (dataAndEvents) {
			if (deepDataAndEvents) {
				srcElements = srcElements || getAll (elem);
				hàm hủy = destElements || getAll (nhân bản);

				for (i = 0, l = srcElements.length; i <l; i ++) {
					cloneCopyEvent (srcElements [i], destElements [i]);
				}
			} khác {
				cloneCopyEvent (elem, clone);
			}
		}

		// Lưu giữ lịch sử đánh giá tập lệnh
		destElements = getAll (clone, "script");
		if (destElements.length> 0) {
			setGlobalEval (destElements,! inPage && getAll (elem, "script"));
		}

		// Trả về tập hợp được nhân bản
		trả lại bản sao;
	},

	cleanData: function (elems) {
		dữ liệu var, elem, type,
			đặc biệt = jQuery.event.special,
			i = 0;

		for (; (elem = elems [i])! == undefined; i ++) {
			if (acceptData (elem)) {
				if ((data = elem [dataPriv.expando])) {
					if (data.events) {
						for (gõ data.events) {
							nếu (đặc biệt [loại]) {
								jQuery.event.remove (elem, type);

							// Đây là một phím tắt để tránh chi phí của jQuery.event.remove
							} khác {
								jQuery.removeEvent (elem, type, data.handle);
							}
						}
					}

					// Hỗ trợ: Chrome <= 35 - 45+
					// Gán undefined thay vì sử dụng delete, hãy xem Data # remove
					elem [dataPriv.expando] = không xác định;
				}
				nếu (elem [dataUser.expando]) {

					// Hỗ trợ: Chrome <= 35 - 45+
					// Gán undefined thay vì sử dụng delete, hãy xem Data # remove
					elem [dataUser.expando] = không xác định;
				}
			}
		}
	}
});

jQuery.fn.extend ({
	tách: chức năng (bộ chọn) {
		return remove (this, selector, true);
	},

	remove: function (selector) {
		trả về loại bỏ (cái này, bộ chọn);
	},

	text: function (value) {
		trả lại quyền truy cập (cái này, hàm (giá trị) {
			giá trị trả về === không xác định?
				jQuery.text (this):
				this.empty (). each (function () {
					if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
						this.textContent = value;
					}
				});
		}, null, giá trị, đối số.length);
	},

	append: function () {
		trả về domManip (this, đối số, hàm (elem) {
			if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
				var target = OperatingTarget (this, elem);
				target.appendChild (elem);
			}
		});
	},

	thêm vào trước: function () {
		trả về domManip (this, đối số, hàm (elem) {
			if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
				var target = OperatingTarget (this, elem);
				target.insertBefore (elem, target.firstChild);
			}
		});
	},

	before: function () {
		trả về domManip (this, đối số, hàm (elem) {
			if (this.parentNode) {
				this.parentNode.insertBefore (elem, this);
			}
		});
	},

	after: function () {
		trả về domManip (this, đối số, hàm (elem) {
			if (this.parentNode) {
				this.parentNode.insertBefore (elem, this.nextSibling);
			}
		});
	},

	rỗng: function () {
		var elem,
			i = 0;

		for (; (elem = this [i])! = null; i ++) {
			if (elem.nodeType === 1) {

				// Ngăn chặn rò rỉ bộ nhớ
				jQuery.cleanData (getAll (elem, false));

				// Loại bỏ bất kỳ nút nào còn lại
				elem.textContent = "";
			}
		}

		trả lại cái này;
	},

	clone: ​​function (dataAndEvents, deepDataAndEvents) {
		dataAndEvents = dataAndEvents == null? sai: dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null? dataAndEvents: deepDataAndEvents;

		return this.map (function () {
			trả về jQuery.clone (this, dataAndEvents, deepDataAndEvents);
		});
	},

	html: function (value) {
		trả lại quyền truy cập (cái này, hàm (giá trị) {
			var elem = this [0] || {},
				i = 0,
				l = this.length;

			if (value === undefined && elem.nodeType === 1) {
				trả về elem.innerHTML;
			}

			// Xem liệu chúng ta có thể sử dụng phím tắt hay không và chỉ sử dụng innerHTML
			if (typeof value === "string" &&! rnoInnerhtml.test (value) &&
				! wrapMap [(rtagName.exec (value) || ["", ""]) [1] .toLowerCase ()]) {

				value = jQuery.htmlPrefilter (giá trị);

				thử {
					cho (; i <l; i ++) {
						elem = this [i] || {};

						// Loại bỏ các nút phần tử và ngăn rò rỉ bộ nhớ
						if (elem.nodeType === 1) {
							jQuery.cleanData (getAll (elem, false));
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// Nếu sử dụng innerHTML ném một ngoại lệ, hãy sử dụng phương thức dự phòng
				} bắt (e) {}
			}

			if (elem) {
				this.empty (). append (value);
			}
		}, null, giá trị, đối số.length);
	},

	ReplaceWith: function () {
		var bỏ qua = [];

		// Thực hiện các thay đổi, thay thế từng phần tử ngữ cảnh không bị bỏ qua bằng nội dung mới
		trả về domManip (this, đối số, hàm (elem) {
			var parent = this.parentNode;

			if (jQuery.inArray (this, bỏ qua) <0) {
				jQuery.cleanData (getAll (this));
				if (cha mẹ) {
					parent.replaceChild (elem, this);
				}
			}

		// Buộc gọi lại lệnh gọi
		}, làm ngơ );
	}
});

jQuery.each ({
	appendTo: "nối thêm",
	prependTo: "thêm trước",
	insertBefore: "trước đây",
	insertAfter: "sau khi",
	ReplaceAll: "ReplaceWith"
}, hàm (tên, ban đầu) {
	jQuery.fn [name] = function (selector) {
		var elems,
			ret = [],
			insert = jQuery (selector),
			last = insert.length - 1,
			i = 0;

		for (; i <= last; i ++) {
			elems = i === cuối cùng? this: this.clone (true);
			jQuery (insert [i]) [original] (elems);

			// Hỗ trợ: chỉ Android <= 4.0, chỉ PhantomJS 1
			// .get () do push.apply (_, arraylike) ném trên WebKit cổ
			push.apply (ret, elems.get ());
		}

		return this.pushStack (ret);
	};
});
var rnumnonpx = new RegExp ("^ (" + pnum + ") (?! px) [az%] + $", "i");

var getStyles = function (elem) {

		// Hỗ trợ: chỉ IE <= 11, Firefox <= 30 (# 15098, # 14150)
		// IE ném vào các phần tử được tạo trong cửa sổ bật lên
		// FF trong khi ném vào các phần tử khung thông qua "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if (! view ||! view.opener) {
			view = cửa sổ;
		}

		trả về view.getComputedStyle (elem);
	};

var swap = function (elem, options, callback) {
	var ret, tên,
		cũ = {};

	// Ghi nhớ các giá trị cũ và chèn các giá trị mới
	cho (tên trong tùy chọn) {
		cũ [tên] = elem.style [tên];
		elem.style [name] = options [tên];
	}

	ret = callback.call (elem);

	// Hoàn nguyên các giá trị cũ
	cho (tên trong tùy chọn) {
		elem.style [name] = old [name];
	}

	trả lại ret;
};


var rboxStyle = new RegExp (cssExpand.join ("|"), "i");



( hàm số() {

	// Thực thi cả hai bài kiểm tra pixelPosition & boxSizingReliable chỉ yêu cầu một bố cục
	// vì vậy chúng được thực thi cùng một lúc để lưu phép tính thứ hai.
	function computeStyleTests () {

		// Đây là một singleton, chúng ta chỉ cần thực thi nó một lần
		if (! div) {
			trở về;
		}

		containerner.style.cssText = "vị trí: tuyệt đối; trái: -11111px; chiều rộng: 60px;" +
			"margin-top: 1px; padding: 0; border: 0";
		div.style.cssText =
			"vị trí: tương đối; hiển thị: khối; hộp-sizing: viền-hộp; tràn: cuộn;" +
			"margin: auto; border: 1px; padding: 1px;" +
			"width: 60%; top: 1%";
		documentElement.appendChild (container) .appendChild (div);

		var divStyle = window.getComputedStyle (div);
		pixelPositionVal = divStyle.top! == "1%";

		// Hỗ trợ: chỉ dành cho Android 4.0 - 4.3, Firefox <= 3 - 44
		TrustMarginLeftVal = roundPixelMeasures (divStyle.marginLeft) === 12;

		// Hỗ trợ: Chỉ Android 4.0 - 4.3, Safari <= 9.1 - 10.1, iOS <= 7.0 - 9.3
		// Một số kiểu quay lại với giá trị phần trăm, mặc dù chúng không nên
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures (divStyle.right) === 36;

		// Hỗ trợ: chỉ IE 9 - 11
		// Phát hiện báo cáo sai về kích thước nội dung cho các phần tử box-sizing: border-box
		boxSizingReliableVal = roundPixelMeasures (divStyle.width) === 36;

		// Hỗ trợ: chỉ IE 9
		// Phát hiện tràn: cuộn vít (gh-3699)
		// Hỗ trợ: Chrome <= 64
		// Không bị lừa khi thu phóng ảnh hưởng đến offsetWidth (gh-4029)
		div.style.position = "tuyệt đối";
		scrollboxSizeVal = roundPixelMeasures (div.offsetWidth / 3) === 12;

		documentElement.removeChild (container);

		// Hủy bỏ div để nó không được lưu trữ trong bộ nhớ và
		// nó cũng sẽ là một dấu hiệu kiểm tra đã được thực hiện
		div = null;
	}

	function roundPixelMeasures (đo lường) {
		return Math.round (parseFloat (đo lường));
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		đáng tin cậyTrDimensionsVal, đáng tin cậyMarginLeftVal,
		container = document.createElement ("div"),
		div = document.createElement ("div");

	// Kết thúc sớm trong môi trường hạn chế (không phải trình duyệt)
	if (! div.style) {
		trở về;
	}

	// Chỉ hỗ trợ: IE <= 9 - 11
	// Kiểu của phần tử được sao chép ảnh hưởng đến phần tử nguồn được sao chép (# 8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode (true) .style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend (hỗ trợ, {
		boxSizingReliable: function () {
			computeStyleTests ();
			trả về hộpSizeReliableVal;
		},
		pixelBoxStyles: function () {
			computeStyleTests ();
			trả về pixelBoxStylesVal;
		},
		pixelPosition: function () {
			computeStyleTests ();
			trả về pixelPositionVal;
		},
		TrustMarginLeft: function () {
			computeStyleTests ();
			trả về đáng tin cậyMarginLeftVal;
		},
		scrollboxSize: function () {
			computeStyleTests ();
			trả về hộp cuộnSizeVal;
		},

		// Hỗ trợ: IE 9 - 11+, Edge 15 - 18+
		// IE / Edge báo cáo sai `getComputedStyle` của các hàng trong bảng có chiều rộng / chiều cao
		// đặt trong CSS trong khi thuộc tính `offset *` báo cáo các giá trị chính xác.
		// Hành vi trong IE 9 tinh tế hơn so với các phiên bản mới hơn và nó vượt qua
		// một số phiên bản của bài kiểm tra này; đảm bảo không làm cho nó vượt qua đó!
		TrustTrDimensions: function () {
			var table, tr, trChild, trStyle;
			if (trustTrDimensionsVal == null) {
				table = document.createElement ("bảng");
				tr = document.createElement ("tr");
				trChild = document.createElement ("div");

				table.style.cssText = "position: tuyệt đối; left: -11111px";
				tr.style.height = "1px";
				trChild.style.height = "9px";

				documentElement
					.appendChild (bảng)
					.appendChild (tr)
					.appendChild (trChild);

				trStyle = window.getComputedStyle (tr);
				TrustTrDimensionsVal = parseInt (trStyle.height)> 3;

				documentElement.removeChild (bảng);
			}
			trả về đáng tin cậyTrDimensionsVal;
		}
	});
}) ();


function curCSS (elem, name, computed) {
	var width, minWidth, maxWidth, ret,

		// Hỗ trợ: Firefox 51+
		// Lấy kiểu trước khi tính bằng cách nào đó
		// khắc phục sự cố nhận các giá trị sai
		// trên các phần tử tách rời
		style = elem.style;

	computed = tính toán || getStyles (elem);

	// getPropertyValue là cần thiết cho:
	// .css ('filter') (chỉ dành cho IE 9, # 12537)
	// .css ('- customProperty) (# 3144)
	nếu (tính) {
		ret = computed.getPropertyValue (tên) || tính [tên];

		if (ret === "" &&! isAttached (elem)) {
			ret = jQuery.style (elem, tên);
		}

		// Tôn vinh "vụ hack tuyệt vời của Dean Edwards"
		// Trình duyệt Android trả về tỷ lệ phần trăm cho một số giá trị,
		// nhưng chiều rộng có vẻ là pixel đáng tin cậy.
		// Điều này trái với thông số kỹ thuật của bản nháp CSSOM:
		// https://drafts.csswg.org/cssom/#resolved-values
		if (! support.pixelBoxStyles () && rnumnonpx.test (ret) && rboxStyle.test (name)) {

			// Nhớ các giá trị ban đầu
			width = style. width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Đặt các giá trị mới vào để lấy ra một giá trị đã tính toán
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Hoàn nguyên các giá trị đã thay đổi
			style.width = chiều rộng;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	trả về ret! == không xác định?

		// Chỉ hỗ trợ: IE <= 9 - 11
		// IE trả về giá trị zIndex dưới dạng số nguyên.
		ret + "":
		ret;
}


function addGetHookIf (conditionFn, hookFn) {

	// Xác định hook, chúng tôi sẽ kiểm tra lần chạy đầu tiên nếu nó thực sự cần thiết.
	trở về {
		get: function () {
			if (conditionFn ()) {

				// Hook không cần thiết (hoặc không thể sử dụng nó do
				// thành phần phụ thuộc bị thiếu), hãy loại bỏ nó.
				xóa this.get;
				trở về;
			}

			// Cần móc; xác định lại nó để kiểm tra hỗ trợ không được thực hiện lại.
			return (this.get = hookFn) .apply (this, các đối số);
		}
	};
}


var cssPrefixes = ["Webkit", "Moz", "ms"],
	voidStyle = document.createElement ("div") .style,
	nhà cung cấp dịch vụ = {};

// Trả về thuộc tính có tiền tố nhà cung cấp hoặc không được xác định
chức năng nhà cung cấpPropName (tên) {

	// Kiểm tra các tên có tiền tố của nhà cung cấp
	var capName = name [0] .toUpperCase () + name.slice (1),
		i = cssPrefixes.length;

	trong khi tôi-- ) {
		name = cssPrefixes [i] + capName;
		if (tên trong Kiểu trống) {
			trả lại tên;
		}
	}
}

// Trả về một jQuery.cssProps có khả năng được ánh xạ hoặc thuộc tính có tiền tố của nhà cung cấp
function finalPropName (tên) {
	var final = jQuery.cssProps [name] || nhà cung cấpProps [tên];

	nếu (cuối cùng) {
		trở lại cuối cùng;
	}
	if (tên trong Kiểu trống) {
		trả lại tên;
	}
	trả lại nhà cung cấpProps [tên] = nhà cung cấpPropName (tên) || Tên;
}


var

	// Có thể thay đổi nếu không hiển thị hoặc bắt đầu bằng bảng
	// ngoại trừ "table", "table-cell" hoặc "table-caption"
	// Xem tại đây để biết các giá trị hiển thị: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = / ^ - /,
	cssShow = {vị trí: "tuyệt đối", khả năng hiển thị: "ẩn", hiển thị: "khối"},
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber (_elem, value, subtract) {

	// Mọi giá trị tương đối (+/-) đã được
	// được chuẩn hóa tại thời điểm này
	var trận đấu = rcssNum.exec (giá trị);
	các trận đấu trở lại?

		// Bảo vệ chống lại "subtract" không xác định, ví dụ: khi được sử dụng như trong cssHooks
		Math.max (0, khớp với [2] - (trừ || 0)) + (khớp với [3] || "px"):
		giá trị;
}

function boxModelAdjustment (elem, kích thước, box, isBorderBox, styles, computedVal) {
	var i = chiều === "chiều rộng"? 1: 0,
		thêm = 0,
		đồng bằng = 0;

	// Có thể không cần điều chỉnh
	if (box === (isBorderBox? "border": "content")) {
		trả về 0;
	}

	cho (; i <4; i + = 2) {

		// Cả hai mô hình hộp đều loại trừ lề
		if (box === "margin") {
			delta + = jQuery.css (elem, box + cssExpand [i], true, styles);
		}

		// Nếu chúng ta đến đây với hộp nội dung, chúng ta đang tìm kiếm "padding" hoặc "border" hoặc "margin"
		if (! isBorderBox) {

			// Thêm phần đệm
			delta + = jQuery.css (elem, "padding" + cssExpand [i], true, styles);

			// Đối với "đường viền" hoặc "lề", hãy thêm đường viền
			if (box! == "padding") {
				delta + = jQuery.css (elem, "border" + cssExpand [i] + "Width", true, styles);

			// Nhưng vẫn theo dõi nó nếu không
			} khác {
				extra + = jQuery.css (elem, "border" + cssExpand [i] + "Width", true, styles);
			}

		// Nếu chúng ta đến đây với một hộp có đường viền (nội dung + đệm + đường viền), chúng ta đang tìm kiếm "nội dung" hoặc
		// "padding" hoặc "margin"
		} khác {

			// Đối với "nội dung", hãy trừ phần đệm
			if (box === "content") {
				delta - = jQuery.css (elem, "padding" + cssExpand [i], true, styles);
			}

			// Đối với "nội dung" hoặc "phần đệm", hãy trừ đường viền
			if (box! == "margin") {
				delta - = jQuery.css (elem, "border" + cssExpand [i] + "Width", true, styles);
			}
		}
	}

	// Tài khoản cho máng xối cuộn hộp nội dung tích cực khi được yêu cầu bằng cách cung cấp computedVal
	if (! isBorderBox && computedVal> = 0) {

		// offsetWidth / offsetHeight là tổng được làm tròn của nội dung, phần đệm, rãnh cuộn và đường viền
		// Giả sử máng xối cuộn số nguyên, trừ phần còn lại và làm tròn xuống
		delta + = Math.max (0, Math.ceil (
			elem ["offset" + kích thước [0] .toUpperCase () + kích thước.slice (1)] -
			computedVal -
			đồng bằng -
			thêm -
			0,5

		// Nếu offsetWidth / offsetHeight không xác định, thì chúng tôi không thể xác định máng xối cuộn hộp nội dung
		// Sử dụng số 0 rõ ràng để tránh NaN (gh-3964)
		)) || Số 0;
	}

	trả lại đồng bằng;
}

function getWidthOrHeight (elem, kích thước, thêm) {

	// Bắt đầu với kiểu tính toán
	var styles = getStyles (elem),

		// Để tránh buộc chỉnh lại, chỉ tìm nạp boxSizing nếu chúng ta cần nó (gh-4322).
		// Hộp nội dung giả mạo cho đến khi chúng ta biết nó cần thiết để biết giá trị thực.
		boxSizingNeeded =! support.boxSizingReliable () || thêm,
		isBorderBox = boxSizingNeeded &&
			jQuery.css (elem, "boxSizing", false, styles) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS (elem, kích thước, kiểu dáng),
		offsetProp = "bù đắp" + kích thước [0] .toUpperCase () + kích thước.slice (1);

	// Hỗ trợ: Firefox <= 54
	// Trả về giá trị không phải pixel gây nhiễu hoặc giả sử không biết, nếu thích hợp.
	if (rnumnonpx.test (val)) {
		if (! extra) {
			trả lại val;
		}
		val = "tự động";
	}


	// Hỗ trợ: chỉ IE 9 - 11
	// Sử dụng offsetWidth / offsetHeight khi định cỡ hộp không đáng tin cậy.
	// Trong những trường hợp đó, giá trị đã tính có thể được tin cậy là hộp viền.
	if ((! support.boxSizingReliable () && isBorderBox ||

		// Hỗ trợ: IE 10 - 11+, Edge 15 - 18+
		// IE / Edge báo cáo sai `getComputedStyle` của các hàng trong bảng có chiều rộng / chiều cao
		// đặt trong CSS trong khi thuộc tính `offset *` báo cáo các giá trị chính xác.
		// Thật thú vị, trong một số trường hợp, IE 9 không gặp phải vấn đề này.
		! support.reliableTrDimensions () && nodeName (elem, "tr") ||

		// Quay lại offsetWidth / offsetHeight khi giá trị là "auto"
		// Điều này xảy ra đối với các phần tử nội tuyến không có cài đặt rõ ràng (gh-3571)
		val === "tự động" ||

		// Chỉ hỗ trợ: Android <= 4.1 - 4.3
		// Cũng sử dụng offsetWidth / offsetHeight cho các kích thước nội tuyến được báo cáo sai (gh-3602)
		! parseFloat (val) && jQuery.css (elem, "display", false, styles) === "inline") &&

		// Đảm bảo phần tử hiển thị và được kết nối
		elem.getClientRects (). length) {

		isBorderBox = jQuery.css (elem, "boxSizing", false, styles) === "border-box";

		// Nếu có sẵn, kích thước hộp đường viền gần đúng offsetWidth / offsetHeight.
		// Nếu không có sẵn (ví dụ: SVG), giả sử định kích thước hộp không đáng tin cậy và diễn giải
		// giá trị được truy xuất dưới dạng thứ nguyên hộp nội dung.
		valueIsBorderBox = offsetProp tính bằng elem;
		if (valueIsBorderBox) {
			val = elem [offsetProp];
		}
	}

	// Chuẩn hóa "" và tự động
	val = parseFloat (val) || Số 0;

	// Điều chỉnh cho mô hình hộp của phần tử
	trở lại (val +
		boxModelAdjustment (
			elem,
			kích thước,
			phụ || (isBorderBox? "border": "content"),
			valueIsBorderBox,
			phong cách,

			// Cung cấp kích thước được tính toán hiện tại để yêu cầu tính toán rãnh cuộn (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend ({

	// Thêm các móc thuộc tính kiểu để ghi đè giá trị mặc định
	// hành vi nhận và thiết lập thuộc tính kiểu
	cssHooks: {
		độ mờ: {
			get: function (elem, computed) {
				nếu (tính) {

					// Chúng ta sẽ luôn lấy lại một số từ độ mờ
					var ret = curCSS (elem, "độ mờ");
					trả về ret === ""? "1": ret;
				}
			}
		}
	},

	// Không tự động thêm "px" vào các thuộc tính có thể là không đơn vị này
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"gridArea": ​​true,
		"gridColumn": true,
		"gridColumnEnd": true,
		"gridColumnStart": true,
		"gridRow": true,
		"gridRowEnd": true,
		"gridRowStart": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"mồ côi": true,
		"góa phụ": true,
		"zIndex": true,
		"zoom": true
	},

	// Thêm các thuộc tính có tên mà bạn muốn sửa trước đó
	// thiết lập hoặc nhận giá trị
	cssProps: {},

	// Lấy và đặt thuộc tính style trên DOM Node
	style: function (elem, name, value, extra) {

		// Không đặt kiểu trên các nút văn bản và nhận xét
		if (! elem || elem.nodeType === 3 || elem.nodeType === 8 ||! elem.style) {
			trở về;
		}

		// Đảm bảo rằng chúng tôi đang làm việc với đúng tên
		var ret, type, hooks,
			origName = camelCase (tên),
			isCustomProp = rcustomProp.test (tên),
			style = elem.style;

		// Đảm bảo rằng chúng tôi đang làm việc với đúng tên. Chúng tôi không
		// muốn truy vấn giá trị nếu nó là thuộc tính tùy chỉnh CSS
		// vì chúng do người dùng định nghĩa.
		if (! isCustomProp) {
			name = finalPropName (origName);
		}

		// Nhận hook cho phiên bản có tiền tố, sau đó là phiên bản không có tiền tố
		hooks = jQuery.cssHooks [name] || jQuery.cssHooks [origName];

		// Kiểm tra xem chúng tôi có đang đặt giá trị không
		if (value! == undefined) {
			type = typeof giá trị;

			// Chuyển "+ =" hoặc "- =" thành số tương đối (# 7345)
			if (type === "string" && (ret = rcssNum.exec (value)) && ret [1]) {
				value = AdjustCSS (elem, name, ret);

				// Sửa lỗi # 9237
				type = "số";
			}

			// Đảm bảo rằng các giá trị null và NaN không được đặt (# 7116)
			if (value == null || value! == value) {
				trở về;
			}

			// Nếu một số được chuyển vào, hãy thêm đơn vị (ngoại trừ một số thuộc tính CSS nhất định)
			// Kiểm tra isCustomProp có thể bị xóa trong jQuery 4.0 khi chúng tôi chỉ tự động nối thêm
			// "px" thành một vài giá trị được mã hóa cứng.
			if (type === "number" &&! isCustomProp) {
				giá trị + = ret && ret [3] || (jQuery.cssNumber [origName]? "": "px");
			}

			// background- * đạo cụ ảnh hưởng đến giá trị của bản sao gốc
			if (! support.clearCloneStyle && value === "" && name.indexOf ("background") === 0) {
				style [name] = "inherit";
			}

			// Nếu cung cấp một hook, hãy sử dụng giá trị đó, nếu không, chỉ cần đặt giá trị được chỉ định
			if (! hooks ||! ("set" in hooks) ||
				(value = hooks.set (elem, value, extra))! == undefined) {

				if (isCustomProp) {
					style.setProperty (tên, giá trị);
				} khác {
					style [name] = value;
				}
			}

		} khác {

			// Nếu một hook được cung cấp, hãy lấy giá trị không tính từ đó
			if (hooks && "get" trong hooks &&
				(ret = hooks.get (elem, false, thêm))! == không xác định) {

				trả lại ret;
			}

			// Nếu không, chỉ lấy giá trị từ đối tượng kiểu
			trả về kiểu [tên];
		}
	},

	css: function (elem, name, extra, styles) {
		var val, num, hooks,
			origName = camelCase (tên),
			isCustomProp = rcustomProp.test (tên);

		// Đảm bảo rằng chúng tôi đang làm việc với đúng tên. Chúng tôi không
		// muốn sửa đổi giá trị nếu nó là thuộc tính tùy chỉnh CSS
		// vì chúng do người dùng định nghĩa.
		if (! isCustomProp) {
			name = finalPropName (origName);
		}

		// Thử tên có tiền tố theo sau là tên không có tiền tố
		hooks = jQuery.cssHooks [name] || jQuery.cssHooks [origName];

		// Nếu một hook được cung cấp, hãy lấy giá trị tính toán từ đó
		if (hooks && "get" trong hooks) {
			val = hooks.get (elem, true, extra);
		}

		// Ngược lại, nếu có một cách để lấy giá trị được tính toán, hãy sử dụng cách đó
		if (val === undefined) {
			val = curCSS (elem, name, styles);
		}

		// Chuyển đổi "bình thường" thành giá trị tính toán
		if (val === "normal" && tên trong cssNormalTransform) {
			val = cssNormalTransform [tên];
		}

		// Tạo thành số nếu bị bắt buộc hoặc cung cấp bộ định lượng và val trông là số
		if (thêm === "" || thêm) {
			num = parseFloat (val);
			trả về thêm === true || isFinite (num)? num || 0: val;
		}

		trả lại val;
	}
});

jQuery.each (["chiều cao", "chiều rộng"], hàm (_i, thứ nguyên) {
	jQuery.cssHooks [kích thước] = {
		get: function (elem, computed, extra) {
			nếu (tính) {

				// Một số phần tử nhất định có thể có thông tin về thứ nguyên nếu chúng tôi hiển thị chúng một cách vô hình
				// nhưng nó phải có kiểu hiển thị hiện tại sẽ có lợi
				trả về rdisplayswap.test (jQuery.css (elem, "display")) &&

					// Hỗ trợ: Safari 8+
					// Các cột của bảng trong Safari có offsetWidth & zero khác không
					// getBoundsClientRect (). width trừ khi thay đổi hiển thị.
					// Chỉ hỗ trợ: IE <= 11
					// Chạy getBoundsClientRect trên một nút bị ngắt kết nối
					// trong IE thông báo lỗi.
					(! elem.getClientRects (). length ||! elem.getBoundsClientRect (). width)?
						swap (elem, cssShow, function () {
							trả về getWidthOrHeight (elem, kích thước, thêm);
						}):
						getWidthOrHeight (elem, kích thước, thêm);
			}
		},

		set: function (elem, value, extra) {
			trận đấu var,
				styles = getStyles (elem),

				// Chỉ đọc styles.position nếu thử nghiệm có khả năng thất bại
				// để tránh buộc chỉnh sửa lại.
				scrollboxSizeBuggy =! support.scrollboxSize () &&
					styles.position === "tuyệt đối",

				// Để tránh buộc chỉnh lại, chỉ tìm nạp boxSizing nếu chúng ta cần (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || thêm,
				isBorderBox = boxSizingNeeded &&
					jQuery.css (elem, "boxSizing", false, styles) === "border-box",
				trừ = thêm?
					boxModelAdjustment (
						elem,
						kích thước,
						thêm,
						isBorderBox,
						phong cách
					):
					Số 0;

			// Giải thích cho các kích thước hộp viền không đáng tin cậy bằng cách so sánh offset * với được tính toán và
			// giả mạo hộp nội dung để lấy đường viền và phần đệm (gh-3699)
			if (isBorderBox && scrollboxSizeBuggy) {
				trừ - = Math.ceil (
					elem ["offset" + kích thước [0] .toUpperCase () + kích thước.slice (1)] -
					parseFloat (phong cách [kích thước]) -
					boxModelAdjustment (elem, kích thước, "border", false, styles) -
					0,5
				);
			}

			// Chuyển đổi thành pixel nếu cần điều chỉnh giá trị
			if (trừ && (trận đấu = rcssNum.exec (giá trị)) &&
				(khớp với [3] || "px")! == "px") {

				elem.style [kích thước] = giá trị;
				value = jQuery.css (elem, kích thước);
			}

			trả về setPositiveNumber (elem, giá trị, số trừ);
		}
	};
});

jQuery.cssHooks.marginLeft = addGetHookIf (support.reliableMarginLeft,
	hàm (elem, tính toán) {
		nếu (tính) {
			return (parseFloat (curCSS (elem, "marginLeft")) ||
				elem.getBoundsClientRect (). left -
					swap (elem, {marginLeft: 0}, function () {
						trả về elem.getBoundsClientRect (). left;
					})
				) + "px";
		}
	}
);

// Các hook này được sử dụng bởi animate để mở rộng các thuộc tính
jQuery.each ({
	lề: "",
	padding: "",
	chiều rộng biên giới"
}, function (tiền tố, hậu tố) {
	jQuery.cssHooks [tiền tố + hậu tố] = {
		mở rộng: hàm (giá trị) {
			var i = 0,
				mở rộng = {},

				// Giả sử một số duy nhất nếu không phải là một chuỗi
				phần = typeof value === "chuỗi"? value.split (""): [value];

			cho (; i <4; i ++) {
				mở rộng [tiền tố + cssExpand [i] + hậu tố] =
					bộ phận [i] || phần [i - 2] || bộ phận [0];
			}

			trở lại được mở rộng;
		}
	};

	if (tiền tố! == "margin") {
		jQuery.cssHooks [tiền tố + hậu tố] .set = setPositiveNumber;
	}
});

jQuery.fn.extend ({
	css: function (tên, giá trị) {
		trả về quyền truy cập (this, function (elem, name, value) {
			var styles, len,
				bản đồ = {},
				i = 0;

			if (Array.isArray (name)) {
				styles = getStyles (elem);
				len = name.length;

				for (; i <len; i ++) {
					map [name [i]] = jQuery.css (elem, name [i], false, styles);
				}

				trả lại bản đồ;
			}

			trả về giá trị! == không xác định?
				jQuery.style (elem, tên, giá trị):
				jQuery.css (elem, tên);
		}, tên, giá trị, các đối số.length> 1);
	}
});


function Tween (elem, options, prop, end, secure) {
	trả về Tween.prototype.init mới (elem, tùy chọn, chống đỡ, kết thúc, nới lỏng);
}
jQuery.Tween = Tween;

Tween.prototype = {
	hàm tạo: Tween,
	init: chức năng (elem, tùy chọn, chống đỡ, kết thúc, nới lỏng, đơn vị) {
		this.elem = elem;
		this.prop = prop;
		this.easing = giảm bớt || jQuery.easing._default;
		this.options = tùy chọn;
		this.start = this.now = this.cur ();
		this.end = end;
		this.unit = unit || (jQuery.cssNumber [prop]? "": "px");
	},
	cur: function () {
		var hooks = Tween.propHooks [this.prop];

		trả lại hook && hooks.get?
			hooks.get (this):
			Tween.propHooks._default.get (this);
	},
	run: function (phần trăm) {
		var giảm bớt,
			hooks = Tween.propHooks [this.prop];

		if (this.options.duration) {
			this.pos = secure = jQuery.easing [this.easing] (
				phần trăm, this.options.duration * phần trăm, 0, 1, this.options.duration
			);
		} khác {
			this.pos = secure = phần trăm;
		}
		this.now = (this.end - this.start) * secure + this.start;

		if (this.options.step) {
			this.options.step.call (this.elem, this.now, this);
		}

		if (hooks && hooks.set) {
			hooks.set (this);
		} khác {
			Tween.propHooks._default.set (this);
		}
		trả lại cái này;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_mặc định: {
		get: function (tween) {
			var kết quả;

			// Sử dụng thuộc tính trực tiếp trên phần tử khi nó không phải là phần tử DOM,
			// hoặc khi không có thuộc tính kiểu phù hợp nào tồn tại.
			if (tween.elem.nodeType! == 1 ||
				tween.elem [tween.prop]! = null && tween.elem.style [tween.prop] == null) {
				trả về tween.elem [tween.prop];
			}

			// Truyền một chuỗi trống làm tham số thứ 3 cho .css sẽ tự động
			// thử phân tích cú pháp và dự phòng cho một chuỗi nếu phân tích cú pháp không thành công.
			// Các giá trị đơn giản như "10px" được phân tích cú pháp thành Float;
			// các giá trị phức tạp như "xoay (1rad)" được trả về nguyên trạng.
			result = jQuery.css (tween.elem, tween.prop, "");

			// Các chuỗi rỗng, null, undefined và "auto" được chuyển thành 0.
			trả về! kết quả || kết quả === "tự động"? 0: kết quả;
		},
		set: function (tween) {

			// Sử dụng step hook cho back compat.
			// Sử dụng cssHook nếu nó ở đó.
			// Sử dụng .style nếu có và sử dụng các thuộc tính thuần túy nếu có.
			if (jQuery.fx.step [tween.prop]) {
				jQuery.fx.step [tween.prop] (tween);
			} else if (tween.elem.nodeType === 1 && (
					jQuery.cssHooks [tween.prop] ||
					tween.elem.style [finalPropName (tween.prop)]! = null)) {
				jQuery.style (tween.elem, tween.prop, tween.now + tween.unit);
			} khác {
				tween.elem [tween.prop] = tween.now;
			}
		}
	}
};

// Chỉ hỗ trợ: IE <= 9
// Phương pháp dựa trên sự hoảng sợ để thiết lập mọi thứ trên các nút bị ngắt kết nối
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function (tween) {
		if (tween.elem.nodeType && tween.elem.parentNode) {
			tween.elem [tween.prop] = tween.now;
		}
	}
};

jQuery.easing = {
	tuyến tính: function (p) {
		trả lại p;
	},
	swing: function (p) {
		return 0,5 - Math.cos (p * Math.PI) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1,8 điểm mở rộng
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = (
					dataPriv.get( cur, "events" ) || Object.create( null )
				)[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {

				// Handle: regular nodes (via `this.ownerDocument`), window
				// (via `this.document`) & document (via `this`).
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( _i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Use a noop converter for missing script
			if ( !isSuccess && jQuery.inArray( "script", s.dataTypes ) > -1 ) {
				s.converters[ "text script" ] = function() {};
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );

jQuery.ajaxPrefilter( function( s ) {
	var i;
	for ( i in s.headers ) {
		if ( i.toLowerCase() === "content-type" ) {
			s.contentType = s.headers[ i ] || "";
		}
	}
} );


jQuery._evalUrl = function( url, options, doc ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options, doc );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			if ( typeof props.top === "number" ) {
				props.top += "px";
			}
			if ( typeof props.left === "number" ) {
				props.left += "px";
			}
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( _i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );

jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( _i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
	return text == null ?
		"" :
		( text + "" ).replace( rtrim, "" );
};



// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === "undefined" ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );